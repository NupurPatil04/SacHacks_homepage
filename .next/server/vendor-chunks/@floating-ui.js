"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui";
exports.ids = ["vendor-chunks/@floating-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   rectToClientRect: () => (/* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\nconst _excluded = [\"crossAxis\", \"alignment\", \"allowedPlacements\", \"autoAlignment\"],\n  _excluded2 = [\"mainAxis\", \"crossAxis\", \"fallbackPlacements\", \"fallbackStrategy\", \"fallbackAxisSideDirection\", \"flipAlignment\"],\n  _excluded3 = [\"strategy\"],\n  _excluded4 = [\"mainAxis\", \"crossAxis\", \"limiter\"],\n  _excluded5 = [\"apply\"];\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n  const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n  const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);\n  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = _objectSpread(_objectSpread({}, middlewareData), {}, {\n      [name]: _objectSpread(_objectSpread({}, middlewareData[name]), data)\n    });\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n  const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n    const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: _objectSpread({\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset\n      }, shouldAddOffset && {\n        alignmentOffset\n      }),\n      reset: shouldAddOffset\n    };\n  }\n});\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment), ...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)] : allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const _evaluate = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          crossAxis = false,\n          alignment,\n          allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements,\n          autoAlignment = true\n        } = _evaluate,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate, _excluded);\n      const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const _evaluate2 = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = true,\n          fallbackPlacements: specifiedFallbackPlacements,\n          fallbackStrategy = 'bestFit',\n          fallbackAxisSideDirection = 'none',\n          flipAlignment = true\n        } = _evaluate2,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate2, _excluded2);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n      const initialSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(initialPlacement);\n      const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const _evaluate3 = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          strategy = 'referenceHidden'\n        } = _evaluate3,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate3, _excluded3);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, _objectSpread(_objectSpread({}, detectOverflowOptions), {}, {\n              elementContext: 'reference'\n            }));\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, _objectSpread(_objectSpread({}, detectOverflowOptions), {}, {\n              altBoundary: true\n            }));\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\nfunction getBoundingRect(rects) {\n  const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.left));\n  const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.top));\n  const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.right));\n  const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));\n      const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'left';\n          const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map(rect => rect.right));\n          const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n  const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n  const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: _objectSpread(_objectSpread({}, diffCoords), {}, {\n          placement\n        })\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const _evaluate4 = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = false,\n          limiter = {\n            fn: _ref => {\n              let {\n                x,\n                y\n              } = _ref;\n              return {\n                x,\n                y\n              };\n            }\n          }\n        } = _evaluate4,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate4, _excluded4);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn(_objectSpread(_objectSpread({}, state), {}, {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      }));\n      return _objectSpread(_objectSpread({}, limitedCoords), {}, {\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      });\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : _objectSpread({\n        mainAxis: 0,\n        crossAxis: 0\n      }, rawOffset);\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const _evaluate5 = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          apply = () => {}\n        } = _evaluate5,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate5, _excluded5);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n      const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n      const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);\n        const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);\n        const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);\n        const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));\n        }\n      }\n      await apply(_objectSpread(_objectSpread({}, state), {}, {\n        availableWidth,\n        availableHeight\n      }));\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNVO0FBQ2hSO0FBRXRELFNBQVNtQiwwQkFBMEJBLENBQUNDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxHQUFHLEVBQUU7RUFDeEQsSUFBSTtJQUNGQyxTQUFTO0lBQ1RDO0VBQ0YsQ0FBQyxHQUFHSixJQUFJO0VBQ1IsTUFBTUssUUFBUSxHQUFHekIsK0RBQVcsQ0FBQ3FCLFNBQVMsQ0FBQztFQUN2QyxNQUFNSyxhQUFhLEdBQUd6QixvRUFBZ0IsQ0FBQ29CLFNBQVMsQ0FBQztFQUNqRCxNQUFNTSxXQUFXLEdBQUd6QixpRUFBYSxDQUFDd0IsYUFBYSxDQUFDO0VBQ2hELE1BQU1FLElBQUksR0FBR3pCLDJEQUFPLENBQUNrQixTQUFTLENBQUM7RUFDL0IsTUFBTVEsVUFBVSxHQUFHSixRQUFRLEtBQUssR0FBRztFQUNuQyxNQUFNSyxPQUFPLEdBQUdQLFNBQVMsQ0FBQ1EsQ0FBQyxHQUFHUixTQUFTLENBQUNTLEtBQUssR0FBRyxDQUFDLEdBQUdSLFFBQVEsQ0FBQ1EsS0FBSyxHQUFHLENBQUM7RUFDdEUsTUFBTUMsT0FBTyxHQUFHVixTQUFTLENBQUNXLENBQUMsR0FBR1gsU0FBUyxDQUFDWSxNQUFNLEdBQUcsQ0FBQyxHQUFHWCxRQUFRLENBQUNXLE1BQU0sR0FBRyxDQUFDO0VBQ3hFLE1BQU1DLFdBQVcsR0FBR2IsU0FBUyxDQUFDSSxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUdILFFBQVEsQ0FBQ0csV0FBVyxDQUFDLEdBQUcsQ0FBQztFQUMxRSxJQUFJVSxNQUFNO0VBQ1YsUUFBUVQsSUFBSTtJQUNWLEtBQUssS0FBSztNQUNSUyxNQUFNLEdBQUc7UUFDUE4sQ0FBQyxFQUFFRCxPQUFPO1FBQ1ZJLENBQUMsRUFBRVgsU0FBUyxDQUFDVyxDQUFDLEdBQUdWLFFBQVEs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LEdBQUdDLElBQUksR0FBRzlPLHVEQUFHLENBQUNnSCxRQUFRLENBQUN4QyxJQUFJLEVBQUV3QyxRQUFRLENBQUN2QyxLQUFLLENBQUMsQ0FBQztRQUM1RyxDQUFDLE1BQU07VUFDTGtLLGVBQWUsR0FBR3pOLE1BQU0sR0FBRyxDQUFDLElBQUk2TixJQUFJLEtBQUssQ0FBQyxJQUFJQyxJQUFJLEtBQUssQ0FBQyxHQUFHRCxJQUFJLEdBQUdDLElBQUksR0FBR2hQLHVEQUFHLENBQUNnSCxRQUFRLENBQUMxQyxHQUFHLEVBQUUwQyxRQUFRLENBQUN6QyxNQUFNLENBQUMsQ0FBQztRQUM5RztNQUNGO01BQ0EsTUFBTTJKLEtBQUssQ0FBQXJMLGFBQUEsQ0FBQUEsYUFBQSxLQUNORSxLQUFLO1FBQ1I2TCxjQUFjO1FBQ2REO01BQWUsRUFDaEIsQ0FBQztNQUNGLE1BQU1NLGNBQWMsR0FBRyxNQUFNeE4sUUFBUSxDQUFDb0QsYUFBYSxDQUFDakMsUUFBUSxDQUFDckMsUUFBUSxDQUFDO01BQ3RFLElBQUlRLEtBQUssS0FBS2tPLGNBQWMsQ0FBQ2xPLEtBQUssSUFBSUcsTUFBTSxLQUFLK04sY0FBYyxDQUFDL04sTUFBTSxFQUFFO1FBQ3RFLE9BQU87VUFDTHdCLEtBQUssRUFBRTtZQUNMWixLQUFLLEVBQUU7VUFDVDtRQUNGLENBQUM7TUFDSDtNQUNBLE9BQU8sQ0FBQyxDQUFDO0lBQ1g7RUFDRixDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NhY2hhY2tzLWhvbWVwYWdlLy4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9jb3JlL2Rpc3QvZmxvYXRpbmctdWkuY29yZS5tanM/NTZiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRTaWRlQXhpcywgZ2V0QWxpZ25tZW50QXhpcywgZ2V0QXhpc0xlbmd0aCwgZ2V0U2lkZSwgZ2V0QWxpZ25tZW50LCBldmFsdWF0ZSwgZ2V0UGFkZGluZ09iamVjdCwgcmVjdFRvQ2xpZW50UmVjdCwgbWluLCBjbGFtcCwgcGxhY2VtZW50cywgZ2V0QWxpZ25tZW50U2lkZXMsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50LCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBzaWRlcywgbWF4LCBnZXRPcHBvc2l0ZUF4aXMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuZXhwb3J0IHsgcmVjdFRvQ2xpZW50UmVjdCB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5cbmZ1bmN0aW9uIGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KF9yZWYsIHBsYWNlbWVudCwgcnRsKSB7XG4gIGxldCB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nXG4gIH0gPSBfcmVmO1xuICBjb25zdCBzaWRlQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudEF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWduTGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChhbGlnbm1lbnRBeGlzKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IHNpZGVBeGlzID09PSAneSc7XG4gIGNvbnN0IGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBmbG9hdGluZy53aWR0aCAvIDI7XG4gIGNvbnN0IGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZmxvYXRpbmcuaGVpZ2h0IC8gMjtcbiAgY29uc3QgY29tbW9uQWxpZ24gPSByZWZlcmVuY2VbYWxpZ25MZW5ndGhdIC8gMiAtIGZsb2F0aW5nW2FsaWduTGVuZ3RoXSAvIDI7XG4gIGxldCBjb29yZHM7XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZmxvYXRpbmcuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGZsb2F0aW5nLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG4gIHN3aXRjaCAoZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkpIHtcbiAgICBjYXNlICdzdGFydCc6XG4gICAgICBjb29yZHNbYWxpZ25tZW50QXhpc10gLT0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSArPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gY29vcmRzO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSBnaXZlbiByZWZlcmVuY2UgZWxlbWVudC5cbiAqXG4gKiBUaGlzIGV4cG9ydCBkb2VzIG5vdCBoYXZlIGFueSBgcGxhdGZvcm1gIGludGVyZmFjZSBsb2dpYy4gWW91IHdpbGwgbmVlZCB0b1xuICogd3JpdGUgb25lIGZvciB0aGUgcGxhdGZvcm0geW91IGFyZSB1c2luZyBGbG9hdGluZyBVSSB3aXRoLlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSBhc3luYyAocmVmZXJlbmNlLCBmbG9hdGluZywgY29uZmlnKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSAnYm90dG9tJyxcbiAgICBzdHJhdGVneSA9ICdhYnNvbHV0ZScsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IHZhbGlkTWlkZGxld2FyZSA9IG1pZGRsZXdhcmUuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGZsb2F0aW5nKSk7XG4gIGxldCByZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIHN0cmF0ZWd5XG4gIH0pO1xuICBsZXQge1xuICAgIHgsXG4gICAgeVxuICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHBsYWNlbWVudCwgcnRsKTtcbiAgbGV0IHN0YXRlZnVsUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICBsZXQgbWlkZGxld2FyZURhdGEgPSB7fTtcbiAgbGV0IHJlc2V0Q291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkTWlkZGxld2FyZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBmblxuICAgIH0gPSB2YWxpZE1pZGRsZXdhcmVbaV07XG4gICAgY29uc3Qge1xuICAgICAgeDogbmV4dFgsXG4gICAgICB5OiBuZXh0WSxcbiAgICAgIGRhdGEsXG4gICAgICByZXNldFxuICAgIH0gPSBhd2FpdCBmbih7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGluaXRpYWxQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH1cbiAgICB9KTtcbiAgICB4ID0gbmV4dFggIT0gbnVsbCA/IG5leHRYIDogeDtcbiAgICB5ID0gbmV4dFkgIT0gbnVsbCA/IG5leHRZIDogeTtcbiAgICBtaWRkbGV3YXJlRGF0YSA9IHtcbiAgICAgIC4uLm1pZGRsZXdhcmVEYXRhLFxuICAgICAgW25hbWVdOiB7XG4gICAgICAgIC4uLm1pZGRsZXdhcmVEYXRhW25hbWVdLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAocmVzZXQgJiYgcmVzZXRDb3VudCA8PSA1MCkge1xuICAgICAgcmVzZXRDb3VudCsrO1xuICAgICAgaWYgKHR5cGVvZiByZXNldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHJlc2V0LnBsYWNlbWVudCkge1xuICAgICAgICAgIHN0YXRlZnVsUGxhY2VtZW50ID0gcmVzZXQucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNldC5yZWN0cykge1xuICAgICAgICAgIHJlY3RzID0gcmVzZXQucmVjdHMgPT09IHRydWUgPyBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgZmxvYXRpbmcsXG4gICAgICAgICAgICBzdHJhdGVneVxuICAgICAgICAgIH0pIDogcmVzZXQucmVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgKHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBzdGF0ZWZ1bFBsYWNlbWVudCwgcnRsKSk7XG4gICAgICB9XG4gICAgICBpID0gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgc3RyYXRlZ3ksXG4gICAgbWlkZGxld2FyZURhdGFcbiAgfTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5IG9uIGVhY2ggc2lkZS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5hc3luYyBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICB2YXIgX2F3YWl0JHBsYXRmb3JtJGlzRWxlO1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhdGZvcm0sXG4gICAgcmVjdHMsXG4gICAgZWxlbWVudHMsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IHN0YXRlO1xuICBjb25zdCB7XG4gICAgYm91bmRhcnkgPSAnY2xpcHBpbmdBbmNlc3RvcnMnLFxuICAgIHJvb3RCb3VuZGFyeSA9ICd2aWV3cG9ydCcsXG4gICAgZWxlbWVudENvbnRleHQgPSAnZmxvYXRpbmcnLFxuICAgIGFsdEJvdW5kYXJ5ID0gZmFsc2UsXG4gICAgcGFkZGluZyA9IDBcbiAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gIGNvbnN0IGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/ICdyZWZlcmVuY2UnIDogJ2Zsb2F0aW5nJztcbiAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgY29uc3QgY2xpcHBpbmdDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChhd2FpdCBwbGF0Zm9ybS5nZXRDbGlwcGluZ1JlY3Qoe1xuICAgIGVsZW1lbnQ6ICgoX2F3YWl0JHBsYXRmb3JtJGlzRWxlID0gYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGVsZW1lbnQpKSkgIT0gbnVsbCA/IF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA6IHRydWUpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgKGF3YWl0IChwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudChlbGVtZW50cy5mbG9hdGluZykpKSxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSkpO1xuICBjb25zdCByZWN0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiByZWN0cy5mbG9hdGluZy53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3RzLmZsb2F0aW5nLmhlaWdodFxuICB9IDogcmVjdHMucmVmZXJlbmNlO1xuICBjb25zdCBvZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgb2Zmc2V0U2NhbGUgPSAoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KG9mZnNldFBhcmVudCkpKSA/IChhd2FpdCAocGxhdGZvcm0uZ2V0U2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldFNjYWxlKG9mZnNldFBhcmVudCkpKSB8fCB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH0gOiB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH07XG4gIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCA/IGF3YWl0IHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9KSA6IHJlY3QpO1xuICByZXR1cm4ge1xuICAgIHRvcDogKGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGJvdHRvbTogKGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGxlZnQ6IChjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQpIC8gb2Zmc2V0U2NhbGUueCxcbiAgICByaWdodDogKGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCkgLyBvZmZzZXRTY2FsZS54XG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gb3B0aW9ucyA9PiAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBvcHRpb25zLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgbWlkZGxld2FyZURhdGFcbiAgICB9ID0gc3RhdGU7XG4gICAgLy8gU2luY2UgYGVsZW1lbnRgIGlzIHJlcXVpcmVkLCB3ZSBkb24ndCBQYXJ0aWFsPD4gdGhlIHR5cGUuXG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCxcbiAgICAgIHBhZGRpbmcgPSAwXG4gICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKSB8fCB7fTtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBjb25zdCBheGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYXhpcyk7XG4gICAgY29uc3QgYXJyb3dEaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50KTtcbiAgICBjb25zdCBpc1lBeGlzID0gYXhpcyA9PT0gJ3knO1xuICAgIGNvbnN0IG1pblByb3AgPSBpc1lBeGlzID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgY29uc3QgbWF4UHJvcCA9IGlzWUF4aXMgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgY29uc3QgY2xpZW50UHJvcCA9IGlzWUF4aXMgPyAnY2xpZW50SGVpZ2h0JyA6ICdjbGllbnRXaWR0aCc7XG4gICAgY29uc3QgZW5kRGlmZiA9IHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdICsgcmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gY29vcmRzW2F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICBjb25zdCBzdGFydERpZmYgPSBjb29yZHNbYXhpc10gLSByZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gICAgY29uc3QgYXJyb3dPZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkpO1xuICAgIGxldCBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBhcnJvd09mZnNldFBhcmVudFtjbGllbnRQcm9wXSA6IDA7XG5cbiAgICAvLyBET00gcGxhdGZvcm0gY2FuIHJldHVybiBgd2luZG93YCBhcyB0aGUgYG9mZnNldFBhcmVudGAuXG4gICAgaWYgKCFjbGllbnRTaXplIHx8ICEoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGFycm93T2Zmc2V0UGFyZW50KSkpKSB7XG4gICAgICBjbGllbnRTaXplID0gZWxlbWVudHMuZmxvYXRpbmdbY2xpZW50UHJvcF0gfHwgcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICB9XG4gICAgY29uc3QgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7XG5cbiAgICAvLyBJZiB0aGUgcGFkZGluZyBpcyBsYXJnZSBlbm91Z2ggdGhhdCBpdCBjYXVzZXMgdGhlIGFycm93IHRvIG5vIGxvbmdlciBiZVxuICAgIC8vIGNlbnRlcmVkLCBtb2RpZnkgdGhlIHBhZGRpbmcgc28gdGhhdCBpdCBpcyBjZW50ZXJlZC5cbiAgICBjb25zdCBsYXJnZXN0UG9zc2libGVQYWRkaW5nID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgLSAxO1xuICAgIGNvbnN0IG1pblBhZGRpbmcgPSBtaW4ocGFkZGluZ09iamVjdFttaW5Qcm9wXSwgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21heFByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpZiB0aGUgY2VudGVyXG4gICAgLy8gcG9pbnQgaXMgb3V0c2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCdzIGJvdW5kcy5cbiAgICBjb25zdCBtaW4kMSA9IG1pblBhZGRpbmc7XG4gICAgY29uc3QgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC0gbWF4UGFkZGluZztcbiAgICBjb25zdCBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICAgIGNvbnN0IG9mZnNldCA9IGNsYW1wKG1pbiQxLCBjZW50ZXIsIG1heCk7XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsIGVub3VnaCB0aGF0IHRoZSBhcnJvdydzIHBhZGRpbmcgY2F1c2VzIGl0IHRvXG4gICAgLy8gdG8gcG9pbnQgdG8gbm90aGluZyBmb3IgYW4gYWxpZ25lZCBwbGFjZW1lbnQsIGFkanVzdCB0aGUgb2Zmc2V0IG9mIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgaXRzZWxmLiBUbyBlbnN1cmUgYHNoaWZ0KClgIGNvbnRpbnVlcyB0byB0YWtlIGFjdGlvbixcbiAgICAvLyBhIHNpbmdsZSByZXNldCBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIGlzIHRydWUuXG4gICAgY29uc3Qgc2hvdWxkQWRkT2Zmc2V0ID0gIW1pZGRsZXdhcmVEYXRhLmFycm93ICYmIGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9IG51bGwgJiYgY2VudGVyICE9PSBvZmZzZXQgJiYgcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gLyAyIC0gKGNlbnRlciA8IG1pbiQxID8gbWluUGFkZGluZyA6IG1heFBhZGRpbmcpIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyIDwgMDtcbiAgICBjb25zdCBhbGlnbm1lbnRPZmZzZXQgPSBzaG91bGRBZGRPZmZzZXQgPyBjZW50ZXIgPCBtaW4kMSA/IGNlbnRlciAtIG1pbiQxIDogY2VudGVyIC0gbWF4IDogMDtcbiAgICByZXR1cm4ge1xuICAgICAgW2F4aXNdOiBjb29yZHNbYXhpc10gKyBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIFtheGlzXTogb2Zmc2V0LFxuICAgICAgICBjZW50ZXJPZmZzZXQ6IGNlbnRlciAtIG9mZnNldCAtIGFsaWdubWVudE9mZnNldCxcbiAgICAgICAgLi4uKHNob3VsZEFkZE9mZnNldCAmJiB7XG4gICAgICAgICAgYWxpZ25tZW50T2Zmc2V0XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgcmVzZXQ6IHNob3VsZEFkZE9mZnNldFxuICAgIH07XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIHtcbiAgY29uc3QgYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCA9IGFsaWdubWVudCA/IFsuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQpLCAuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9PSBhbGlnbm1lbnQpXSA6IGFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0U2lkZShwbGFjZW1lbnQpID09PSBwbGFjZW1lbnQpO1xuICByZXR1cm4gYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudC5maWx0ZXIocGxhY2VtZW50ID0+IHtcbiAgICBpZiAoYWxpZ25tZW50KSB7XG4gICAgICByZXR1cm4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCB8fCAoYXV0b0FsaWdubWVudCA/IGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkgIT09IHBsYWNlbWVudCA6IGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2F1dG9QbGFjZW1lbnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXV0b1AsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDIsIF9wbGFjZW1lbnRzVGhhdEZpdE9uRTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgYWxpZ25tZW50LFxuICAgICAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMsXG4gICAgICAgIGF1dG9BbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzJDEgPSBhbGlnbm1lbnQgIT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkUGxhY2VtZW50cyA9PT0gcGxhY2VtZW50cyA/IGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50IHx8IG51bGwsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSA6IGFsbG93ZWRQbGFjZW1lbnRzO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9ICgoX21pZGRsZXdhcmVEYXRhJGF1dG9QID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUC5pbmRleCkgfHwgMDtcbiAgICAgIGNvbnN0IGN1cnJlbnRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4XTtcbiAgICAgIGlmIChjdXJyZW50UGxhY2VtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3QgYWxpZ25tZW50U2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhjdXJyZW50UGxhY2VtZW50LCByZWN0cywgYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKTtcblxuICAgICAgLy8gTWFrZSBgY29tcHV0ZUNvb3Jkc2Agc3RhcnQgZnJvbSB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICBpZiAocGxhY2VtZW50ICE9PSBjdXJyZW50UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50cyQxWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudE92ZXJmbG93cyA9IFtvdmVyZmxvd1tnZXRTaWRlKGN1cnJlbnRQbGFjZW1lbnQpXSwgb3ZlcmZsb3dbYWxpZ25tZW50U2lkZXNbMF1dLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1sxXV1dO1xuICAgICAgY29uc3QgYWxsT3ZlcmZsb3dzID0gWy4uLigoKF9taWRkbGV3YXJlRGF0YSRhdXRvUDIgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QMi5vdmVyZmxvd3MpIHx8IFtdKSwge1xuICAgICAgICBwbGFjZW1lbnQ6IGN1cnJlbnRQbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93czogY3VycmVudE92ZXJmbG93c1xuICAgICAgfV07XG4gICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50cyQxW2N1cnJlbnRJbmRleCArIDFdO1xuXG4gICAgICAvLyBUaGVyZSBhcmUgbW9yZSBwbGFjZW1lbnRzIHRvIGNoZWNrLlxuICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlID0gYWxsT3ZlcmZsb3dzLm1hcChkID0+IHtcbiAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KGQucGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIFtkLnBsYWNlbWVudCwgYWxpZ25tZW50ICYmIGNyb3NzQXhpcyA/XG4gICAgICAgIC8vIENoZWNrIGFsb25nIHRoZSBtYWluQXhpcyBhbmQgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgZC5vdmVyZmxvd3Muc2xpY2UoMCwgMikucmVkdWNlKChhY2MsIHYpID0+IGFjYyArIHYsIDApIDpcbiAgICAgICAgLy8gQ2hlY2sgb25seSB0aGUgbWFpbkF4aXMuXG4gICAgICAgIGQub3ZlcmZsb3dzWzBdLCBkLm92ZXJmbG93c107XG4gICAgICB9KS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGUgPSBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UuZmlsdGVyKGQgPT4gZFsyXS5zbGljZSgwLFxuICAgICAgLy8gQWxpZ25lZCBwbGFjZW1lbnRzIHNob3VsZCBub3QgY2hlY2sgdGhlaXIgb3Bwb3NpdGUgY3Jvc3NBeGlzXG4gICAgICAvLyBzaWRlLlxuICAgICAgZ2V0QWxpZ25tZW50KGRbMF0pID8gMiA6IDMpLmV2ZXJ5KHYgPT4gdiA8PSAwKSk7XG4gICAgICBjb25zdCByZXNldFBsYWNlbWVudCA9ICgoX3BsYWNlbWVudHNUaGF0Rml0T25FID0gcGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3BsYWNlbWVudHNUaGF0Rml0T25FWzBdKSB8fCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2VbMF1bMF07XG4gICAgICBpZiAocmVzZXRQbGFjZW1lbnQgIT09IHBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdmbGlwJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGFycm93LCBfbWlkZGxld2FyZURhdGEkZmxpcDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIGluaXRpYWxQbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlLFxuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgICAgZmFsbGJhY2tTdHJhdGVneSA9ICdiZXN0Rml0JyxcbiAgICAgICAgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9ICdub25lJyxcbiAgICAgICAgZmxpcEFsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcblxuICAgICAgLy8gSWYgYSByZXNldCBieSB0aGUgYXJyb3cgd2FzIGNhdXNlZCBkdWUgdG8gYW4gYWxpZ25tZW50IG9mZnNldCBiZWluZ1xuICAgICAgLy8gYWRkZWQsIHdlIHNob3VsZCBza2lwIGFueSBsb2dpYyBub3cgc2luY2UgYGZsaXAoKWAgaGFzIGFscmVhZHkgZG9uZSBpdHNcbiAgICAgIC8vIHdvcmsuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzI1NDkjaXNzdWVjb21tZW50LTE3MTk2MDE2NDNcbiAgICAgIGlmICgoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaW5pdGlhbFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoaW5pdGlhbFBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpc0Jhc2VQbGFjZW1lbnQgPSBnZXRTaWRlKGluaXRpYWxQbGFjZW1lbnQpID09PSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICAgICAgY29uc3QgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBBbGlnbm1lbnQgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoaW5pdGlhbFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQpKTtcbiAgICAgIGNvbnN0IGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gPSBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uICE9PSAnbm9uZSc7XG4gICAgICBpZiAoIXNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyAmJiBoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50cy5wdXNoKC4uLmdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiwgcnRsKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzID0gW2luaXRpYWxQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c107XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dzID0gW107XG4gICAgICBsZXQgb3ZlcmZsb3dzRGF0YSA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAub3ZlcmZsb3dzKSB8fCBbXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVdKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBzaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCk7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVzWzBdXSwgb3ZlcmZsb3dbc2lkZXNbMV1dKTtcbiAgICAgIH1cbiAgICAgIG92ZXJmbG93c0RhdGEgPSBbLi4ub3ZlcmZsb3dzRGF0YSwge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93c1xuICAgICAgfV07XG5cbiAgICAgIC8vIE9uZSBvciBtb3JlIHNpZGVzIGlzIG92ZXJmbG93aW5nLlxuICAgICAgaWYgKCFvdmVyZmxvd3MuZXZlcnkoc2lkZSA9PiBzaWRlIDw9IDApKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkZmxpcDIsIF9vdmVyZmxvd3NEYXRhJGZpbHRlcjtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKCgoX21pZGRsZXdhcmVEYXRhJGZsaXAyID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwMi5pbmRleCkgfHwgMCkgKyAxO1xuICAgICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50c1tuZXh0SW5kZXhdO1xuICAgICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICAgIGNvbnN0IGlnbm9yZUNyb3NzQXhpc092ZXJmbG93ID0gY2hlY2tDcm9zc0F4aXMgPT09ICdhbGlnbm1lbnQnID8gaW5pdGlhbFNpZGVBeGlzICE9PSBnZXRTaWRlQXhpcyhuZXh0UGxhY2VtZW50KSA6IGZhbHNlO1xuICAgICAgICAgIGlmICghaWdub3JlQ3Jvc3NBeGlzT3ZlcmZsb3cgfHxcbiAgICAgICAgICAvLyBXZSBsZWF2ZSB0aGUgY3VycmVudCBtYWluIGF4aXMgb25seSBpZiBldmVyeSBwbGFjZW1lbnQgb24gdGhhdCBheGlzXG4gICAgICAgICAgLy8gb3ZlcmZsb3dzIHRoZSBtYWluIGF4aXMuXG4gICAgICAgICAgb3ZlcmZsb3dzRGF0YS5ldmVyeShkID0+IGdldFNpZGVBeGlzKGQucGxhY2VtZW50KSA9PT0gaW5pdGlhbFNpZGVBeGlzID8gZC5vdmVyZmxvd3NbMF0gPiAwIDogdHJ1ZSkpIHtcbiAgICAgICAgICAgIC8vIFRyeSBuZXh0IHBsYWNlbWVudCBhbmQgcmUtcnVuIHRoZSBsaWZlY3ljbGUuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgICAgICAgICBvdmVyZmxvd3M6IG92ZXJmbG93c0RhdGFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCwgZmluZCB0aGUgY2FuZGlkYXRlcyB0aGF0IGZpdCBvbiB0aGUgbWFpbkF4aXMgc2lkZSBvZiBvdmVyZmxvdyxcbiAgICAgICAgLy8gdGhlbiBmaW5kIHRoZSBwbGFjZW1lbnQgdGhhdCBmaXRzIHRoZSBiZXN0IG9uIHRoZSBtYWluIGNyb3NzQXhpcyBzaWRlLlxuICAgICAgICBsZXQgcmVzZXRQbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkZmlsdGVyID0gb3ZlcmZsb3dzRGF0YS5maWx0ZXIoZCA9PiBkLm92ZXJmbG93c1swXSA8PSAwKS5zb3J0KChhLCBiKSA9PiBhLm92ZXJmbG93c1sxXSAtIGIub3ZlcmZsb3dzWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJGZpbHRlci5wbGFjZW1lbnQ7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGZhbGxiYWNrLlxuICAgICAgICBpZiAoIXJlc2V0UGxhY2VtZW50KSB7XG4gICAgICAgICAgc3dpdGNoIChmYWxsYmFja1N0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjYXNlICdiZXN0Rml0JzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IChfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIyID0gb3ZlcmZsb3dzRGF0YS5maWx0ZXIoZCA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoaGFzRmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2lkZUF4aXMgPSBnZXRTaWRlQXhpcyhkLnBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2lkZUF4aXMgPT09IGluaXRpYWxTaWRlQXhpcyB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBiaWFzIHRvIHRoZSBgeWAgc2lkZSBheGlzIGR1ZSB0byBob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRpbmcgZGlyZWN0aW9ucyBmYXZvcmluZyBncmVhdGVyIHdpZHRoLlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2lkZUF4aXMgPT09ICd5JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pLm1hcChkID0+IFtkLnBsYWNlbWVudCwgZC5vdmVyZmxvd3MuZmlsdGVyKG92ZXJmbG93ID0+IG92ZXJmbG93ID4gMCkucmVkdWNlKChhY2MsIG92ZXJmbG93KSA9PiBhY2MgKyBvdmVyZmxvdywgMCldKS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIyWzBdO1xuICAgICAgICAgICAgICAgIGlmIChwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaW5pdGlhbFBsYWNlbWVudCc6XG4gICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFjZW1lbnQgIT09IHJlc2V0UGxhY2VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgIHBsYWNlbWVudDogcmVzZXRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aFxuICB9O1xufVxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBzaWRlcy5zb21lKHNpZGUgPT4gb3ZlcmZsb3dbc2lkZV0gPj0gMCk7XG59XG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaGlkZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHJhdGVneSA9ICdyZWZlcmVuY2VIaWRkZW4nLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICAgIGNhc2UgJ3JlZmVyZW5jZUhpZGRlbic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VIaWRkZW46IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvZmZzZXRzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZXNjYXBlZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdHMuZmxvYXRpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGVzY2FwZWRPZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICAgICAgICAgIGVzY2FwZWQ6IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvZmZzZXRzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdChyZWN0cykge1xuICBjb25zdCBtaW5YID0gbWluKC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QubGVmdCkpO1xuICBjb25zdCBtaW5ZID0gbWluKC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QudG9wKSk7XG4gIGNvbnN0IG1heFggPSBtYXgoLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICBjb25zdCBtYXhZID0gbWF4KC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QuYm90dG9tKSk7XG4gIHJldHVybiB7XG4gICAgeDogbWluWCxcbiAgICB5OiBtaW5ZLFxuICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRSZWN0c0J5TGluZShyZWN0cykge1xuICBjb25zdCBzb3J0ZWRSZWN0cyA9IHJlY3RzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYS55IC0gYi55KTtcbiAgY29uc3QgZ3JvdXBzID0gW107XG4gIGxldCBwcmV2UmVjdCA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydGVkUmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByZWN0ID0gc29ydGVkUmVjdHNbaV07XG4gICAgaWYgKCFwcmV2UmVjdCB8fCByZWN0LnkgLSBwcmV2UmVjdC55ID4gcHJldlJlY3QuaGVpZ2h0IC8gMikge1xuICAgICAgZ3JvdXBzLnB1c2goW3JlY3RdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXBzW2dyb3Vwcy5sZW5ndGggLSAxXS5wdXNoKHJlY3QpO1xuICAgIH1cbiAgICBwcmV2UmVjdCA9IHJlY3Q7XG4gIH1cbiAgcmV0dXJuIGdyb3Vwcy5tYXAocmVjdCA9PiByZWN0VG9DbGllbnRSZWN0KGdldEJvdW5kaW5nUmVjdChyZWN0KSkpO1xufVxuLyoqXG4gKiBQcm92aWRlcyBpbXByb3ZlZCBwb3NpdGlvbmluZyBmb3IgaW5saW5lIHJlZmVyZW5jZSBlbGVtZW50cyB0aGF0IGNhbiBzcGFuXG4gKiBvdmVyIG11bHRpcGxlIGxpbmVzLCBzdWNoIGFzIGh5cGVybGlua3Mgb3IgcmFuZ2Ugc2VsZWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbmxpbmVcbiAqL1xuY29uc3QgaW5saW5lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdpbmxpbmUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgLy8gQSBNb3VzZUV2ZW50J3MgY2xpZW50e1gsWX0gY29vcmRzIGNhbiBiZSB1cCB0byAyIHBpeGVscyBvZmYgYVxuICAgICAgLy8gQ2xpZW50UmVjdCdzIGJvdW5kcywgZGVzcGl0ZSB0aGUgZXZlbnQgbGlzdGVuZXIgYmVpbmcgdHJpZ2dlcmVkLiBBXG4gICAgICAvLyBwYWRkaW5nIG9mIDIgc2VlbXMgdG8gaGFuZGxlIHRoaXMgaXNzdWUuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhZGRpbmcgPSAyLFxuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgbmF0aXZlQ2xpZW50UmVjdHMgPSBBcnJheS5mcm9tKChhd2FpdCAocGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldENsaWVudFJlY3RzKGVsZW1lbnRzLnJlZmVyZW5jZSkpKSB8fCBbXSk7XG4gICAgICBjb25zdCBjbGllbnRSZWN0cyA9IGdldFJlY3RzQnlMaW5lKG5hdGl2ZUNsaWVudFJlY3RzKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrID0gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QobmF0aXZlQ2xpZW50UmVjdHMpKTtcbiAgICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICAgICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgdHdvIHJlY3RzIGFuZCB0aGV5IGFyZSBkaXNqb2luZWQuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPT09IDIgJiYgY2xpZW50UmVjdHNbMF0ubGVmdCA+IGNsaWVudFJlY3RzWzFdLnJpZ2h0ICYmIHggIT0gbnVsbCAmJiB5ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCByZWN0IGluIHdoaWNoIHRoZSBwb2ludCBpcyBmdWxseSBpbnNpZGUuXG4gICAgICAgICAgcmV0dXJuIGNsaWVudFJlY3RzLmZpbmQocmVjdCA9PiB4ID4gcmVjdC5sZWZ0IC0gcGFkZGluZ09iamVjdC5sZWZ0ICYmIHggPCByZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCAmJiB5ID4gcmVjdC50b3AgLSBwYWRkaW5nT2JqZWN0LnRvcCAmJiB5IDwgcmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgfHwgZmFsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVyZSBhcmUgMiBvciBtb3JlIGNvbm5lY3RlZCByZWN0cy5cbiAgICAgICAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgaWYgKGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5Jykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RSZWN0ID0gY2xpZW50UmVjdHNbMF07XG4gICAgICAgICAgICBjb25zdCBsYXN0UmVjdCA9IGNsaWVudFJlY3RzW2NsaWVudFJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgaXNUb3AgPSBnZXRTaWRlKHBsYWNlbWVudCkgPT09ICd0b3AnO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gZmlyc3RSZWN0LnRvcDtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IGxhc3RSZWN0LmJvdHRvbTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBpc1RvcCA/IGZpcnN0UmVjdC5sZWZ0IDogbGFzdFJlY3QubGVmdDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gaXNUb3AgPyBmaXJzdFJlY3QucmlnaHQgOiBsYXN0UmVjdC5yaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzTGVmdFNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCkgPT09ICdsZWZ0JztcbiAgICAgICAgICBjb25zdCBtYXhSaWdodCA9IG1heCguLi5jbGllbnRSZWN0cy5tYXAocmVjdCA9PiByZWN0LnJpZ2h0KSk7XG4gICAgICAgICAgY29uc3QgbWluTGVmdCA9IG1pbiguLi5jbGllbnRSZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlUmVjdHMgPSBjbGllbnRSZWN0cy5maWx0ZXIocmVjdCA9PiBpc0xlZnRTaWRlID8gcmVjdC5sZWZ0ID09PSBtaW5MZWZ0IDogcmVjdC5yaWdodCA9PT0gbWF4UmlnaHQpO1xuICAgICAgICAgIGNvbnN0IHRvcCA9IG1lYXN1cmVSZWN0c1swXS50b3A7XG4gICAgICAgICAgY29uc3QgYm90dG9tID0gbWVhc3VyZVJlY3RzW21lYXN1cmVSZWN0cy5sZW5ndGggLSAxXS5ib3R0b207XG4gICAgICAgICAgY29uc3QgbGVmdCA9IG1pbkxlZnQ7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSBtYXhSaWdodDtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzZXRSZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgICAgICB9LFxuICAgICAgICBmbG9hdGluZzogZWxlbWVudHMuZmxvYXRpbmcsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICAgIGlmIChyZWN0cy5yZWZlcmVuY2UueCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UueCB8fCByZWN0cy5yZWZlcmVuY2UueSAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UueSB8fCByZWN0cy5yZWZlcmVuY2Uud2lkdGggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLndpZHRoIHx8IHJlY3RzLnJlZmVyZW5jZS5oZWlnaHQgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogcmVzZXRSZWN0c1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBvcmlnaW5TaWRlcyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFsnbGVmdCcsICd0b3AnXSk7XG5cbi8vIEZvciB0eXBlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB0aGUgYE9mZnNldE9wdGlvbnNgIHR5cGUgd2FzIGFsc29cbi8vIERlcml2YWJsZS5cblxuYXN5bmMgZnVuY3Rpb24gY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50c1xuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gIGNvbnN0IG1haW5BeGlzTXVsdGkgPSBvcmlnaW5TaWRlcy5oYXMoc2lkZSkgPyAtMSA6IDE7XG4gIGNvbnN0IGNyb3NzQXhpc011bHRpID0gcnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDE7XG4gIGNvbnN0IHJhd1ZhbHVlID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHtcbiAgICBtYWluQXhpcyxcbiAgICBjcm9zc0F4aXMsXG4gICAgYWxpZ25tZW50QXhpc1xuICB9ID0gdHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGxcbiAgfSA6IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUubWFpbkF4aXMgfHwgMCxcbiAgICBjcm9zc0F4aXM6IHJhd1ZhbHVlLmNyb3NzQXhpcyB8fCAwLFxuICAgIGFsaWdubWVudEF4aXM6IHJhd1ZhbHVlLmFsaWdubWVudEF4aXNcbiAgfTtcbiAgaWYgKGFsaWdubWVudCAmJiB0eXBlb2YgYWxpZ25tZW50QXhpcyA9PT0gJ251bWJlcicpIHtcbiAgICBjcm9zc0F4aXMgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gYWxpZ25tZW50QXhpcyAqIC0xIDogYWxpZ25tZW50QXhpcztcbiAgfVxuICByZXR1cm4gaXNWZXJ0aWNhbCA/IHtcbiAgICB4OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aSxcbiAgICB5OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGlcbiAgfSA6IHtcbiAgICB4OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGksXG4gICAgeTogY3Jvc3NBeGlzICogY3Jvc3NBeGlzTXVsdGlcbiAgfTtcbn1cblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ29mZnNldCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJGFycm93O1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCBkaWZmQ29vcmRzID0gYXdhaXQgY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBJZiB0aGUgcGxhY2VtZW50IGlzIHRoZSBzYW1lIGFuZCB0aGUgYXJyb3cgY2F1c2VkIGFuIGFsaWdubWVudCBvZmZzZXRcbiAgICAgIC8vIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byBjaGFuZ2UgdGhlIHBvc2l0aW9uaW5nIGNvb3JkaW5hdGVzLlxuICAgICAgaWYgKHBsYWNlbWVudCA9PT0gKChfbWlkZGxld2FyZURhdGEkb2Zmc2UgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UucGxhY2VtZW50KSAmJiAoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgZGlmZkNvb3Jkcy54LFxuICAgICAgICB5OiB5ICsgZGlmZkNvb3Jkcy55LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgLi4uZGlmZkNvb3JkcyxcbiAgICAgICAgICBwbGFjZW1lbnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NoaWZ0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgbGltaXRlciA9IHtcbiAgICAgICAgICBmbjogX3JlZiA9PiB7XG4gICAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMoZ2V0U2lkZShwbGFjZW1lbnQpKTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBtYWluQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IG1haW5BeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgbWFpbkF4aXNDb29yZCA9IGNsYW1wKG1pbiwgbWFpbkF4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBjcm9zc0F4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBjcm9zc0F4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGNsYW1wKG1pbiwgY3Jvc3NBeGlzQ29vcmQsIG1heCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW1pdGVkQ29vcmRzID0gbGltaXRlci5mbih7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubGltaXRlZENvb3JkcyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHg6IGxpbWl0ZWRDb29yZHMueCAtIHgsXG4gICAgICAgICAgeTogbGltaXRlZENvb3Jkcy55IC0geSxcbiAgICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgICBbbWFpbkF4aXNdOiBjaGVja01haW5BeGlzLFxuICAgICAgICAgICAgW2Nyb3NzQXhpc106IGNoZWNrQ3Jvc3NBeGlzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG4gICAgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyb3NzQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE9wcG9zaXRlQXhpcyhjcm9zc0F4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICBjb25zdCByYXdPZmZzZXQgPSBldmFsdWF0ZShvZmZzZXQsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvbXB1dGVkT2Zmc2V0ID0gdHlwZW9mIHJhd09mZnNldCA9PT0gJ251bWJlcicgPyB7XG4gICAgICAgIG1haW5BeGlzOiByYXdPZmZzZXQsXG4gICAgICAgIGNyb3NzQXhpczogMFxuICAgICAgfSA6IHtcbiAgICAgICAgbWFpbkF4aXM6IDAsXG4gICAgICAgIGNyb3NzQXhpczogMCxcbiAgICAgICAgLi4ucmF3T2Zmc2V0XG4gICAgICB9O1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSAtIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBpZiAobWFpbkF4aXNDb29yZCA8IGxpbWl0TWluKSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKG1haW5BeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIG1haW5BeGlzQ29vcmQgPSBsaW1pdE1heDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkb2Zmc2UsIF9taWRkbGV3YXJlRGF0YSRvZmZzZTI7XG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IGlzT3JpZ2luU2lkZSA9IG9yaWdpblNpZGVzLmhhcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIChpc09yaWdpblNpZGUgPyAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZVtjcm9zc0F4aXNdKSB8fCAwIDogMCkgKyAoaXNPcmlnaW5TaWRlID8gMCA6IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSArIChpc09yaWdpblNpZGUgPyAwIDogKChfbWlkZGxld2FyZURhdGEkb2Zmc2UyID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlMltjcm9zc0F4aXNdKSB8fCAwKSAtIChpc09yaWdpblNpZGUgPyBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMgOiAwKTtcbiAgICAgICAgaWYgKGNyb3NzQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQXhpc0Nvb3JkID4gbGltaXRNYXgpIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdzaXplJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX3N0YXRlJG1pZGRsZXdhcmVEYXRhLCBfc3RhdGUkbWlkZGxld2FyZURhdGEyO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXBwbHkgPSAoKSA9PiB7fSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzWUF4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSByZWN0cy5mbG9hdGluZztcbiAgICAgIGxldCBoZWlnaHRTaWRlO1xuICAgICAgbGV0IHdpZHRoU2lkZTtcbiAgICAgIGlmIChzaWRlID09PSAndG9wJyB8fCBzaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBoZWlnaHRTaWRlID0gc2lkZTtcbiAgICAgICAgd2lkdGhTaWRlID0gYWxpZ25tZW50ID09PSAoKGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSkgPyAnc3RhcnQnIDogJ2VuZCcpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoU2lkZSA9IHNpZGU7XG4gICAgICAgIGhlaWdodFNpZGUgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ0hlaWdodCA9IGhlaWdodCAtIG92ZXJmbG93LnRvcCAtIG92ZXJmbG93LmJvdHRvbTtcbiAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ1dpZHRoID0gd2lkdGggLSBvdmVyZmxvdy5sZWZ0IC0gb3ZlcmZsb3cucmlnaHQ7XG4gICAgICBjb25zdCBvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCA9IG1pbihoZWlnaHQgLSBvdmVyZmxvd1toZWlnaHRTaWRlXSwgbWF4aW11bUNsaXBwaW5nSGVpZ2h0KTtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlV2lkdGggPSBtaW4od2lkdGggLSBvdmVyZmxvd1t3aWR0aFNpZGVdLCBtYXhpbXVtQ2xpcHBpbmdXaWR0aCk7XG4gICAgICBjb25zdCBub1NoaWZ0ID0gIXN0YXRlLm1pZGRsZXdhcmVEYXRhLnNoaWZ0O1xuICAgICAgbGV0IGF2YWlsYWJsZUhlaWdodCA9IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgbGV0IGF2YWlsYWJsZVdpZHRoID0gb3ZlcmZsb3dBdmFpbGFibGVXaWR0aDtcbiAgICAgIGlmICgoX3N0YXRlJG1pZGRsZXdhcmVEYXRhID0gc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQpICE9IG51bGwgJiYgX3N0YXRlJG1pZGRsZXdhcmVEYXRhLmVuYWJsZWQueCkge1xuICAgICAgICBhdmFpbGFibGVXaWR0aCA9IG1heGltdW1DbGlwcGluZ1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKChfc3RhdGUkbWlkZGxld2FyZURhdGEyID0gc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQpICE9IG51bGwgJiYgX3N0YXRlJG1pZGRsZXdhcmVEYXRhMi5lbmFibGVkLnkpIHtcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbWF4aW11bUNsaXBwaW5nSGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKG5vU2hpZnQgJiYgIWFsaWdubWVudCkge1xuICAgICAgICBjb25zdCB4TWluID0gbWF4KG92ZXJmbG93LmxlZnQsIDApO1xuICAgICAgICBjb25zdCB4TWF4ID0gbWF4KG92ZXJmbG93LnJpZ2h0LCAwKTtcbiAgICAgICAgY29uc3QgeU1pbiA9IG1heChvdmVyZmxvdy50b3AsIDApO1xuICAgICAgICBjb25zdCB5TWF4ID0gbWF4KG92ZXJmbG93LmJvdHRvbSwgMCk7XG4gICAgICAgIGlmIChpc1lBeGlzKSB7XG4gICAgICAgICAgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIDIgKiAoeE1pbiAhPT0gMCB8fCB4TWF4ICE9PSAwID8geE1pbiArIHhNYXggOiBtYXgob3ZlcmZsb3cubGVmdCwgb3ZlcmZsb3cucmlnaHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSAyICogKHlNaW4gIT09IDAgfHwgeU1heCAhPT0gMCA/IHlNaW4gKyB5TWF4IDogbWF4KG92ZXJmbG93LnRvcCwgb3ZlcmZsb3cuYm90dG9tKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YWl0IGFwcGx5KHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgICBhdmFpbGFibGVIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV4dERpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICAgIGlmICh3aWR0aCAhPT0gbmV4dERpbWVuc2lvbnMud2lkdGggfHwgaGVpZ2h0ICE9PSBuZXh0RGltZW5zaW9ucy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSB9O1xuIl0sIm5hbWVzIjpbImdldFNpZGVBeGlzIiwiZ2V0QWxpZ25tZW50QXhpcyIsImdldEF4aXNMZW5ndGgiLCJnZXRTaWRlIiwiZ2V0QWxpZ25tZW50IiwiZXZhbHVhdGUiLCJnZXRQYWRkaW5nT2JqZWN0IiwicmVjdFRvQ2xpZW50UmVjdCIsIm1pbiIsImNsYW1wIiwicGxhY2VtZW50cyIsImdldEFsaWdubWVudFNpZGVzIiwiZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsImdldEV4cGFuZGVkUGxhY2VtZW50cyIsImdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMiLCJzaWRlcyIsIm1heCIsImdldE9wcG9zaXRlQXhpcyIsImNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50IiwiX3JlZiIsInBsYWNlbWVudCIsInJ0bCIsInJlZmVyZW5jZSIsImZsb2F0aW5nIiwic2lkZUF4aXMiLCJhbGlnbm1lbnRBeGlzIiwiYWxpZ25MZW5ndGgiLCJzaWRlIiwiaXNWZXJ0aWNhbCIsImNvbW1vblgiLCJ4Iiwid2lkdGgiLCJjb21tb25ZIiwieSIsImhlaWdodCIsImNvbW1vbkFsaWduIiwiY29vcmRzIiwiY29tcHV0ZVBvc2l0aW9uIiwiY29uZmlnIiwic3RyYXRlZ3kiLCJtaWRkbGV3YXJlIiwicGxhdGZvcm0iLCJ2YWxpZE1pZGRsZXdhcmUiLCJmaWx0ZXIiLCJCb29sZWFuIiwiaXNSVEwiLCJyZWN0cyIsImdldEVsZW1lbnRSZWN0cyIsInN0YXRlZnVsUGxhY2VtZW50IiwibWlkZGxld2FyZURhdGEiLCJyZXNldENvdW50IiwiaSIsImxlbmd0aCIsIm5hbWUiLCJmbiIsIm5leHRYIiwibmV4dFkiLCJkYXRhIiwicmVzZXQiLCJpbml0aWFsUGxhY2VtZW50IiwiZWxlbWVudHMiLCJfb2JqZWN0U3ByZWFkIiwiZGV0ZWN0T3ZlcmZsb3ciLCJzdGF0ZSIsIm9wdGlvbnMiLCJfYXdhaXQkcGxhdGZvcm0kaXNFbGUiLCJib3VuZGFyeSIsInJvb3RCb3VuZGFyeSIsImVsZW1lbnRDb250ZXh0IiwiYWx0Qm91bmRhcnkiLCJwYWRkaW5nIiwicGFkZGluZ09iamVjdCIsImFsdENvbnRleHQiLCJlbGVtZW50IiwiY2xpcHBpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiaXNFbGVtZW50IiwiY29udGV4dEVsZW1lbnQiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJyZWN0Iiwib2Zmc2V0UGFyZW50IiwiZ2V0T2Zmc2V0UGFyZW50Iiwib2Zmc2V0U2NhbGUiLCJnZXRTY2FsZSIsImVsZW1lbnRDbGllbnRSZWN0IiwiY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJhcnJvdyIsImF4aXMiLCJhcnJvd0RpbWVuc2lvbnMiLCJnZXREaW1lbnNpb25zIiwiaXNZQXhpcyIsIm1pblByb3AiLCJtYXhQcm9wIiwiY2xpZW50UHJvcCIsImVuZERpZmYiLCJzdGFydERpZmYiLCJhcnJvd09mZnNldFBhcmVudCIsImNsaWVudFNpemUiLCJjZW50ZXJUb1JlZmVyZW5jZSIsImxhcmdlc3RQb3NzaWJsZVBhZGRpbmciLCJtaW5QYWRkaW5nIiwibWF4UGFkZGluZyIsIm1pbiQxIiwiY2VudGVyIiwib2Zmc2V0Iiwic2hvdWxkQWRkT2Zmc2V0IiwiYWxpZ25tZW50T2Zmc2V0IiwiY2VudGVyT2Zmc2V0IiwiZ2V0UGxhY2VtZW50TGlzdCIsImFsaWdubWVudCIsImF1dG9BbGlnbm1lbnQiLCJhbGxvd2VkUGxhY2VtZW50cyIsImFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQiLCJhdXRvUGxhY2VtZW50IiwiX21pZGRsZXdhcmVEYXRhJGF1dG9QIiwiX21pZGRsZXdhcmVEYXRhJGF1dG9QMiIsIl9wbGFjZW1lbnRzVGhhdEZpdE9uRSIsIl9ldmFsdWF0ZSIsImNyb3NzQXhpcyIsImRldGVjdE92ZXJmbG93T3B0aW9ucyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsIl9leGNsdWRlZCIsInBsYWNlbWVudHMkMSIsInVuZGVmaW5lZCIsIm92ZXJmbG93IiwiY3VycmVudEluZGV4IiwiaW5kZXgiLCJjdXJyZW50UGxhY2VtZW50IiwiYWxpZ25tZW50U2lkZXMiLCJjdXJyZW50T3ZlcmZsb3dzIiwiYWxsT3ZlcmZsb3dzIiwib3ZlcmZsb3dzIiwibmV4dFBsYWNlbWVudCIsInBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZSIsIm1hcCIsImQiLCJzbGljZSIsInJlZHVjZSIsImFjYyIsInYiLCJzb3J0IiwiYSIsImIiLCJwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGUiLCJldmVyeSIsInJlc2V0UGxhY2VtZW50IiwiZmxpcCIsIl9taWRkbGV3YXJlRGF0YSRhcnJvdyIsIl9taWRkbGV3YXJlRGF0YSRmbGlwIiwiX2V2YWx1YXRlMiIsIm1haW5BeGlzIiwiY2hlY2tNYWluQXhpcyIsImNoZWNrQ3Jvc3NBeGlzIiwiZmFsbGJhY2tQbGFjZW1lbnRzIiwic3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIiwiZmFsbGJhY2tTdHJhdGVneSIsImZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24iLCJmbGlwQWxpZ25tZW50IiwiX2V4Y2x1ZGVkMiIsImluaXRpYWxTaWRlQXhpcyIsImlzQmFzZVBsYWNlbWVudCIsImhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24iLCJwdXNoIiwib3ZlcmZsb3dzRGF0YSIsIl9taWRkbGV3YXJlRGF0YSRmbGlwMiIsIl9vdmVyZmxvd3NEYXRhJGZpbHRlciIsIm5leHRJbmRleCIsImlnbm9yZUNyb3NzQXhpc092ZXJmbG93IiwiX292ZXJmbG93c0RhdGEkZmlsdGVyMiIsImN1cnJlbnRTaWRlQXhpcyIsImdldFNpZGVPZmZzZXRzIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwic29tZSIsImhpZGUiLCJfZXZhbHVhdGUzIiwiX2V4Y2x1ZGVkMyIsIm9mZnNldHMiLCJyZWZlcmVuY2VIaWRkZW5PZmZzZXRzIiwicmVmZXJlbmNlSGlkZGVuIiwiZXNjYXBlZE9mZnNldHMiLCJlc2NhcGVkIiwiZ2V0Qm91bmRpbmdSZWN0IiwibWluWCIsIm1pblkiLCJtYXhYIiwibWF4WSIsImdldFJlY3RzQnlMaW5lIiwic29ydGVkUmVjdHMiLCJncm91cHMiLCJwcmV2UmVjdCIsImlubGluZSIsIm5hdGl2ZUNsaWVudFJlY3RzIiwiQXJyYXkiLCJmcm9tIiwiZ2V0Q2xpZW50UmVjdHMiLCJjbGllbnRSZWN0cyIsImZhbGxiYWNrIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZmluZCIsImZpcnN0UmVjdCIsImxhc3RSZWN0IiwiaXNUb3AiLCJpc0xlZnRTaWRlIiwibWF4UmlnaHQiLCJtaW5MZWZ0IiwibWVhc3VyZVJlY3RzIiwicmVzZXRSZWN0cyIsIm9yaWdpblNpZGVzIiwiU2V0IiwiY29udmVydFZhbHVlVG9Db29yZHMiLCJtYWluQXhpc011bHRpIiwiaGFzIiwiY3Jvc3NBeGlzTXVsdGkiLCJyYXdWYWx1ZSIsIl9taWRkbGV3YXJlRGF0YSRvZmZzZSIsImRpZmZDb29yZHMiLCJzaGlmdCIsIl9ldmFsdWF0ZTQiLCJsaW1pdGVyIiwiX2V4Y2x1ZGVkNCIsIm1haW5BeGlzQ29vcmQiLCJjcm9zc0F4aXNDb29yZCIsIm1pblNpZGUiLCJtYXhTaWRlIiwibGltaXRlZENvb3JkcyIsImVuYWJsZWQiLCJsaW1pdFNoaWZ0IiwicmF3T2Zmc2V0IiwiY29tcHV0ZWRPZmZzZXQiLCJsZW4iLCJsaW1pdE1pbiIsImxpbWl0TWF4IiwiX21pZGRsZXdhcmVEYXRhJG9mZnNlMiIsImlzT3JpZ2luU2lkZSIsInNpemUiLCJfc3RhdGUkbWlkZGxld2FyZURhdGEiLCJfc3RhdGUkbWlkZGxld2FyZURhdGEyIiwiX2V2YWx1YXRlNSIsImFwcGx5IiwiX2V4Y2x1ZGVkNSIsImhlaWdodFNpZGUiLCJ3aWR0aFNpZGUiLCJtYXhpbXVtQ2xpcHBpbmdIZWlnaHQiLCJtYXhpbXVtQ2xpcHBpbmdXaWR0aCIsIm92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0Iiwib3ZlcmZsb3dBdmFpbGFibGVXaWR0aCIsIm5vU2hpZnQiLCJhdmFpbGFibGVIZWlnaHQiLCJhdmFpbGFibGVXaWR0aCIsInhNaW4iLCJ4TWF4IiwieU1pbiIsInlNYXgiLCJuZXh0RGltZW5zaW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   platform: () => (/* binding */ platform),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/core */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\nfunction getCssDimensions(element) {\n  const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\nfunction unwrapElement(element) {\n  return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(domElement)) {\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.width) : rect.width) / width;\n  let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\nconst noOffsets = /*#__PURE__*/(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\nfunction getVisualOffsets(element) {\n  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element)) {\n    return false;\n  }\n  return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(domElement);\n    const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(currentIFrame);\n      currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);\n    }\n  }\n  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\nfunction getHTMLOffset(documentElement, scroll) {\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);\n  const topLayer = elements ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {\n      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);\n    }\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n  const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element);\n  const body = element.ownerDocument.body;\n  const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(body).direction === 'rtl') {\n    x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Safety check: ensure the scrollbar space is reasonable in case this\n// calculation is affected by unusual styles.\n// Most scrollbars leave 15-18px of space.\nconst SCROLLBAR_MAX = 25;\nfunction getViewportRect(element, strategy) {\n  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  const windowScrollbarX = getWindowScrollBarX(html);\n  // <html> `overflow: hidden` + `scrollbar-gutter: stable` reduces the\n  // visual width of the <html> but this is not considered in the size\n  // of `html.clientWidth`.\n  if (windowScrollbarX <= 0) {\n    const doc = html.ownerDocument;\n    const body = doc.body;\n    const bodyStyles = getComputedStyle(body);\n    const bodyMarginInline = doc.compatMode === 'CSS1Compat' ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;\n    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);\n    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {\n      width -= clippingStableScrollbarWidth;\n    }\n  } else if (windowScrollbarX <= SCROLLBAR_MAX) {\n    // If the <body> scrollbar is on the left, the width needs to be extended\n    // by the scrollbar amount so there isn't extra space on the right.\n    width += windowScrollbarX;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element));\n  } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);\n  if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(parentNode)) {\n    return false;\n  }\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(element, [], false).filter(el => (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'fixed';\n  let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(currentNode)) {\n    const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentNode);\n    const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.top, accRect.top);\n    accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.right, accRect.right);\n    accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.bottom, accRect.bottom);\n    accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);\n  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {\n      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction isStaticPositioned(element) {\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'static';\n}\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element)) {\n    return win;\n  }\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n    let svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);\n    while (svgOffsetParent && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(svgOffsetParent)) {\n      if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTableElement)(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(offsetParent) && isStaticPositioned(offsetParent) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(offsetParent)) {\n    return win;\n  }\n  return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getContainingBlock)(element) || win;\n}\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\nfunction isRTL(element) {\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).direction === 'rtl';\n}\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement,\n  isRTL\n};\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(top);\n    const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientWidth - (left + width));\n    const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientHeight - (top + height));\n    const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, _objectSpread(_objectSpread({}, options), {}, {\n        // Handle <iframe>s\n        root: root.ownerDocument\n      }));\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(referenceEl) : []), ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.detectOverflow;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.offset;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.autoPlacement;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.shift;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.flip;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.size;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.hide;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.arrow;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.inline;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.limitShift;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = _objectSpread({\n    platform\n  }, options);\n  const platformWithCache = _objectSpread(_objectSpread({}, mergedOptions.platform), {}, {\n    _c: cache\n  });\n  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.computePosition)(reference, floating, _objectSpread(_objectSpread({}, mergedOptions), {}, {\n    platform: platformWithCache\n  }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5VDtBQUMvTztBQUN3UTtBQUNwUjtBQUU5RCxTQUFTOEMsZ0JBQWdCQSxDQUFDQyxPQUFPLEVBQUU7RUFDakMsTUFBTUMsR0FBRyxHQUFHbkIsd0VBQWtCLENBQUNrQixPQUFPLENBQUM7RUFDdkM7RUFDQTtFQUNBLElBQUlFLEtBQUssR0FBR0MsVUFBVSxDQUFDRixHQUFHLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUM7RUFDdEMsSUFBSUUsTUFBTSxHQUFHRCxVQUFVLENBQUNGLEdBQUcsQ0FBQ0csTUFBTSxDQUFDLElBQUksQ0FBQztFQUN4QyxNQUFNQyxTQUFTLEdBQUd0QixxRUFBYSxDQUFDaUIsT0FBTyxDQUFDO0VBQ3hDLE1BQU1NLFdBQVcsR0FBR0QsU0FBUyxHQUFHTCxPQUFPLENBQUNNLFdBQVcsR0FBR0osS0FBSztFQUMzRCxNQUFNSyxZQUFZLEdBQUdGLFNBQVMsR0FBR0wsT0FBTyxDQUFDTyxZQUFZLEdBQUdILE1BQU07RUFDOUQsTUFBTUksY0FBYyxHQUFHaEMseURBQUssQ0FBQzBCLEtBQUssQ0FBQyxLQUFLSSxXQUFXLElBQUk5Qix5REFBSyxDQUFDNEIsTUFBTSxDQUFDLEtBQUtHLFlBQVk7RUFDckYsSUFBSUMsY0FBYyxFQUFFO0lBQ2xCTixLQUFLLEdBQUdJLFdBQVc7SUFDbkJGLE1BQU0sR0FBR0csWUFBWTtFQUN2QjtFQUNBLE9BQU87SUFDTEwsS0FBSztJQUNMRSxNQUFNO0lBQ05LLENBQUMsRUFBRUQ7RUFDTCxDQUFDO0FBQ0g7QUFFQSxTQUFTRSxhQUFhQSxDQUFDVixPQUFPLEVBQUU7RUFDOUIsT0FBTyxDQUFDaEIsaUVBQVMsQ0FBQ2dCLE9BQU8sQ0FBQyxHQUFHQSxPQUFPLENBQUNXLGNBQWMsR0FBR1gsT0FBTztBQUMvRDtBQUVBLFNBQVNZ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RCxPQUFPNUgsa0VBQWlCLENBQUNzSyxTQUFTLEVBQUVsRixRQUFRLEVBQUFrSCxhQUFBLENBQUFBLGFBQUEsS0FDdkNnQyxhQUFhO0lBQ2hCOUQsUUFBUSxFQUFFK0Q7RUFBaUIsRUFDNUIsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYWNoYWNrcy1ob21lcGFnZS8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvZG9tL2Rpc3QvZmxvYXRpbmctdWkuZG9tLm1qcz8zZmEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlY3RUb0NsaWVudFJlY3QsIGFycm93IGFzIGFycm93JDEsIGF1dG9QbGFjZW1lbnQgYXMgYXV0b1BsYWNlbWVudCQxLCBkZXRlY3RPdmVyZmxvdyBhcyBkZXRlY3RPdmVyZmxvdyQxLCBmbGlwIGFzIGZsaXAkMSwgaGlkZSBhcyBoaWRlJDEsIGlubGluZSBhcyBpbmxpbmUkMSwgbGltaXRTaGlmdCBhcyBsaW1pdFNoaWZ0JDEsIG9mZnNldCBhcyBvZmZzZXQkMSwgc2hpZnQgYXMgc2hpZnQkMSwgc2l6ZSBhcyBzaXplJDEsIGNvbXB1dGVQb3NpdGlvbiBhcyBjb21wdXRlUG9zaXRpb24kMSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmltcG9ydCB7IHJvdW5kLCBjcmVhdGVDb29yZHMsIG1heCwgbWluLCBmbG9vciB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5pbXBvcnQgeyBnZXRDb21wdXRlZFN0eWxlIGFzIGdldENvbXB1dGVkU3R5bGUkMSwgaXNIVE1MRWxlbWVudCwgaXNFbGVtZW50LCBnZXRXaW5kb3csIGlzV2ViS2l0LCBnZXRGcmFtZUVsZW1lbnQsIGdldE5vZGVTY3JvbGwsIGdldERvY3VtZW50RWxlbWVudCwgaXNUb3BMYXllciwgZ2V0Tm9kZU5hbWUsIGlzT3ZlcmZsb3dFbGVtZW50LCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgZ2V0UGFyZW50Tm9kZSwgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBpc0NvbnRhaW5pbmdCbG9jaywgaXNUYWJsZUVsZW1lbnQsIGdldENvbnRhaW5pbmdCbG9jayB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuZXhwb3J0IHsgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcblxuZnVuY3Rpb24gZ2V0Q3NzRGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KTtcbiAgLy8gSW4gdGVzdGluZyBlbnZpcm9ubWVudHMsIHRoZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBwcm9wZXJ0aWVzIGFyZSBlbXB0eVxuICAvLyBzdHJpbmdzIGZvciBTVkcgZWxlbWVudHMsIHJldHVybmluZyBOYU4uIEZhbGxiYWNrIHRvIGAwYCBpbiB0aGlzIGNhc2UuXG4gIGxldCB3aWR0aCA9IHBhcnNlRmxvYXQoY3NzLndpZHRoKSB8fCAwO1xuICBsZXQgaGVpZ2h0ID0gcGFyc2VGbG9hdChjc3MuaGVpZ2h0KSB8fCAwO1xuICBjb25zdCBoYXNPZmZzZXQgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBvZmZzZXRXaWR0aCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0V2lkdGggOiB3aWR0aDtcbiAgY29uc3Qgb2Zmc2V0SGVpZ2h0ID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRIZWlnaHQgOiBoZWlnaHQ7XG4gIGNvbnN0IHNob3VsZEZhbGxiYWNrID0gcm91bmQod2lkdGgpICE9PSBvZmZzZXRXaWR0aCB8fCByb3VuZChoZWlnaHQpICE9PSBvZmZzZXRIZWlnaHQ7XG4gIGlmIChzaG91bGRGYWxsYmFjaykge1xuICAgIHdpZHRoID0gb2Zmc2V0V2lkdGg7XG4gICAgaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICQ6IHNob3VsZEZhbGxiYWNrXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVud3JhcEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gIWlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgOiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZG9tRWxlbWVudCkpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29vcmRzKDEpO1xuICB9XG4gIGNvbnN0IHJlY3QgPSBkb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZG9tRWxlbWVudCk7XG4gIGxldCB4ID0gKCQgPyByb3VuZChyZWN0LndpZHRoKSA6IHJlY3Qud2lkdGgpIC8gd2lkdGg7XG4gIGxldCB5ID0gKCQgPyByb3VuZChyZWN0LmhlaWdodCkgOiByZWN0LmhlaWdodCkgLyBoZWlnaHQ7XG5cbiAgLy8gMCwgTmFOLCBvciBJbmZpbml0eSBzaG91bGQgYWx3YXlzIGZhbGxiYWNrIHRvIDEuXG5cbiAgaWYgKCF4IHx8ICFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICB4ID0gMTtcbiAgfVxuICBpZiAoIXkgfHwgIU51bWJlci5pc0Zpbml0ZSh5KSkge1xuICAgIHkgPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmNvbnN0IG5vT2Zmc2V0cyA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb29yZHMoMCk7XG5mdW5jdGlvbiBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoIWlzV2ViS2l0KCkgfHwgIXdpbi52aXN1YWxWaWV3cG9ydCkge1xuICAgIHJldHVybiBub09mZnNldHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCxcbiAgICB5OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wXG4gIH07XG59XG5mdW5jdGlvbiBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGVsZW1lbnQsIGlzRml4ZWQsIGZsb2F0aW5nT2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cbiAgaWYgKCFmbG9hdGluZ09mZnNldFBhcmVudCB8fCBpc0ZpeGVkICYmIGZsb2F0aW5nT2Zmc2V0UGFyZW50ICE9PSBnZXRXaW5kb3coZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQ7XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG4gIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBpZiAoaW5jbHVkZVNjYWxlKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudCkge1xuICAgICAgaWYgKGlzRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCwgaXNGaXhlZFN0cmF0ZWd5LCBvZmZzZXRQYXJlbnQpID8gZ2V0VmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgbGV0IHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgdmlzdWFsT2Zmc2V0cy54KSAvIHNjYWxlLng7XG4gIGxldCB5ID0gKGNsaWVudFJlY3QudG9wICsgdmlzdWFsT2Zmc2V0cy55KSAvIHNjYWxlLnk7XG4gIGxldCB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZS54O1xuICBsZXQgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZS55O1xuICBpZiAoZG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhkb21FbGVtZW50KTtcbiAgICBjb25zdCBvZmZzZXRXaW4gPSBvZmZzZXRQYXJlbnQgJiYgaXNFbGVtZW50KG9mZnNldFBhcmVudCkgPyBnZXRXaW5kb3cob2Zmc2V0UGFyZW50KSA6IG9mZnNldFBhcmVudDtcbiAgICBsZXQgY3VycmVudFdpbiA9IHdpbjtcbiAgICBsZXQgY3VycmVudElGcmFtZSA9IGdldEZyYW1lRWxlbWVudChjdXJyZW50V2luKTtcbiAgICB3aGlsZSAoY3VycmVudElGcmFtZSAmJiBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0V2luICE9PSBjdXJyZW50V2luKSB7XG4gICAgICBjb25zdCBpZnJhbWVTY2FsZSA9IGdldFNjYWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgaWZyYW1lUmVjdCA9IGN1cnJlbnRJRnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlJDEoY3VycmVudElGcmFtZSk7XG4gICAgICBjb25zdCBsZWZ0ID0gaWZyYW1lUmVjdC5sZWZ0ICsgKGN1cnJlbnRJRnJhbWUuY2xpZW50TGVmdCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdMZWZ0KSkgKiBpZnJhbWVTY2FsZS54O1xuICAgICAgY29uc3QgdG9wID0gaWZyYW1lUmVjdC50b3AgKyAoY3VycmVudElGcmFtZS5jbGllbnRUb3AgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nVG9wKSkgKiBpZnJhbWVTY2FsZS55O1xuICAgICAgeCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgeSAqPSBpZnJhbWVTY2FsZS55O1xuICAgICAgd2lkdGggKj0gaWZyYW1lU2NhbGUueDtcbiAgICAgIGhlaWdodCAqPSBpZnJhbWVTY2FsZS55O1xuICAgICAgeCArPSBsZWZ0O1xuICAgICAgeSArPSB0b3A7XG4gICAgICBjdXJyZW50V2luID0gZ2V0V2luZG93KGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY3VycmVudElGcmFtZSA9IGdldEZyYW1lRWxlbWVudChjdXJyZW50V2luKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3Qoe1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfSk7XG59XG5cbi8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbi8vIGluY29ycmVjdCBmb3IgUlRMLlxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50LCByZWN0KSB7XG4gIGNvbnN0IGxlZnRTY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG4gIGlmICghcmVjdCkge1xuICAgIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgbGVmdFNjcm9sbDtcbiAgfVxuICByZXR1cm4gcmVjdC5sZWZ0ICsgbGVmdFNjcm9sbDtcbn1cblxuZnVuY3Rpb24gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCkge1xuICBjb25zdCBodG1sUmVjdCA9IGRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgeCA9IGh0bWxSZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50LCBodG1sUmVjdCk7XG4gIGNvbnN0IHkgPSBodG1sUmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wO1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgZWxlbWVudHMsXG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGlzRml4ZWQgPSBzdHJhdGVneSA9PT0gJ2ZpeGVkJztcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IHRvcExheWVyID0gZWxlbWVudHMgPyBpc1RvcExheWVyKGVsZW1lbnRzLmZsb2F0aW5nKSA6IGZhbHNlO1xuICBpZiAob2Zmc2V0UGFyZW50ID09PSBkb2N1bWVudEVsZW1lbnQgfHwgdG9wTGF5ZXIgJiYgaXNGaXhlZCkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG4gICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfVxuICB9XG4gIGNvbnN0IGh0bWxPZmZzZXQgPSBkb2N1bWVudEVsZW1lbnQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkID8gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGggKiBzY2FsZS54LFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKiBzY2FsZS55LFxuICAgIHg6IHJlY3QueCAqIHNjYWxlLnggLSBzY3JvbGwuc2Nyb2xsTGVmdCAqIHNjYWxlLnggKyBvZmZzZXRzLnggKyBodG1sT2Zmc2V0LngsXG4gICAgeTogcmVjdC55ICogc2NhbGUueSAtIHNjcm9sbC5zY3JvbGxUb3AgKiBzY2FsZS55ICsgb2Zmc2V0cy55ICsgaHRtbE9mZnNldC55XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RzKGVsZW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5nZXRDbGllbnRSZWN0cygpKTtcbn1cblxuLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZS5cbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCk7XG4gIGNvbnN0IGJvZHkgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgY29uc3Qgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keS5zY3JvbGxXaWR0aCwgYm9keS5jbGllbnRXaWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5LmNsaWVudEhlaWdodCk7XG4gIGxldCB4ID0gLXNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgY29uc3QgeSA9IC1zY3JvbGwuc2Nyb2xsVG9wO1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSQxKGJvZHkpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5LmNsaWVudFdpZHRoKSAtIHdpZHRoO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG4vLyBTYWZldHkgY2hlY2s6IGVuc3VyZSB0aGUgc2Nyb2xsYmFyIHNwYWNlIGlzIHJlYXNvbmFibGUgaW4gY2FzZSB0aGlzXG4vLyBjYWxjdWxhdGlvbiBpcyBhZmZlY3RlZCBieSB1bnVzdWFsIHN0eWxlcy5cbi8vIE1vc3Qgc2Nyb2xsYmFycyBsZWF2ZSAxNS0xOHB4IG9mIHNwYWNlLlxuY29uc3QgU0NST0xMQkFSX01BWCA9IDI1O1xuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIGxldCB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIGxldCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgIGNvbnN0IHZpc3VhbFZpZXdwb3J0QmFzZWQgPSBpc1dlYktpdCgpO1xuICAgIGlmICghdmlzdWFsVmlld3BvcnRCYXNlZCB8fCB2aXN1YWxWaWV3cG9ydEJhc2VkICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG4gIGNvbnN0IHdpbmRvd1Njcm9sbGJhclggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGh0bWwpO1xuICAvLyA8aHRtbD4gYG92ZXJmbG93OiBoaWRkZW5gICsgYHNjcm9sbGJhci1ndXR0ZXI6IHN0YWJsZWAgcmVkdWNlcyB0aGVcbiAgLy8gdmlzdWFsIHdpZHRoIG9mIHRoZSA8aHRtbD4gYnV0IHRoaXMgaXMgbm90IGNvbnNpZGVyZWQgaW4gdGhlIHNpemVcbiAgLy8gb2YgYGh0bWwuY2xpZW50V2lkdGhgLlxuICBpZiAod2luZG93U2Nyb2xsYmFyWCA8PSAwKSB7XG4gICAgY29uc3QgZG9jID0gaHRtbC5vd25lckRvY3VtZW50O1xuICAgIGNvbnN0IGJvZHkgPSBkb2MuYm9keTtcbiAgICBjb25zdCBib2R5U3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShib2R5KTtcbiAgICBjb25zdCBib2R5TWFyZ2luSW5saW5lID0gZG9jLmNvbXBhdE1vZGUgPT09ICdDU1MxQ29tcGF0JyA/IHBhcnNlRmxvYXQoYm9keVN0eWxlcy5tYXJnaW5MZWZ0KSArIHBhcnNlRmxvYXQoYm9keVN0eWxlcy5tYXJnaW5SaWdodCkgfHwgMCA6IDA7XG4gICAgY29uc3QgY2xpcHBpbmdTdGFibGVTY3JvbGxiYXJXaWR0aCA9IE1hdGguYWJzKGh0bWwuY2xpZW50V2lkdGggLSBib2R5LmNsaWVudFdpZHRoIC0gYm9keU1hcmdpbklubGluZSk7XG4gICAgaWYgKGNsaXBwaW5nU3RhYmxlU2Nyb2xsYmFyV2lkdGggPD0gU0NST0xMQkFSX01BWCkge1xuICAgICAgd2lkdGggLT0gY2xpcHBpbmdTdGFibGVTY3JvbGxiYXJXaWR0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAod2luZG93U2Nyb2xsYmFyWCA8PSBTQ1JPTExCQVJfTUFYKSB7XG4gICAgLy8gSWYgdGhlIDxib2R5PiBzY3JvbGxiYXIgaXMgb24gdGhlIGxlZnQsIHRoZSB3aWR0aCBuZWVkcyB0byBiZSBleHRlbmRlZFxuICAgIC8vIGJ5IHRoZSBzY3JvbGxiYXIgYW1vdW50IHNvIHRoZXJlIGlzbid0IGV4dHJhIHNwYWNlIG9uIHRoZSByaWdodC5cbiAgICB3aWR0aCArPSB3aW5kb3dTY3JvbGxiYXJYO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5jb25zdCBhYnNvbHV0ZU9yRml4ZWQgPSAvKiNfX1BVUkVfXyovbmV3IFNldChbJ2Fic29sdXRlJywgJ2ZpeGVkJ10pO1xuLy8gUmV0dXJucyB0aGUgaW5uZXIgY2xpZW50IHJlY3QsIHN1YnRyYWN0aW5nIHNjcm9sbGJhcnMgaWYgcHJlc2VudC5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICBjb25zdCB0b3AgPSBjbGllbnRSZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICBjb25zdCBsZWZ0ID0gY2xpZW50UmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICBjb25zdCBzY2FsZSA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRTY2FsZShlbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygxKTtcbiAgY29uc3Qgd2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoICogc2NhbGUueDtcbiAgY29uc3QgaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY2FsZS55O1xuICBjb25zdCB4ID0gbGVmdCAqIHNjYWxlLng7XG4gIGNvbnN0IHkgPSB0b3AgKiBzY2FsZS55O1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkge1xuICBsZXQgcmVjdDtcbiAgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICd2aWV3cG9ydCcpIHtcbiAgICByZWN0ID0gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAnZG9jdW1lbnQnKSB7XG4gICAgcmVjdCA9IGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpO1xuICB9IGVsc2UgaWYgKGlzRWxlbWVudChjbGlwcGluZ0FuY2VzdG9yKSkge1xuICAgIHJlY3QgPSBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCk7XG4gICAgcmVjdCA9IHtcbiAgICAgIHg6IGNsaXBwaW5nQW5jZXN0b3IueCAtIHZpc3VhbE9mZnNldHMueCxcbiAgICAgIHk6IGNsaXBwaW5nQW5jZXN0b3IueSAtIHZpc3VhbE9mZnNldHMueSxcbiAgICAgIHdpZHRoOiBjbGlwcGluZ0FuY2VzdG9yLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjbGlwcGluZ0FuY2VzdG9yLmhlaWdodFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3QocmVjdCk7XG59XG5mdW5jdGlvbiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgc3RvcE5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGlmIChwYXJlbnROb2RlID09PSBzdG9wTm9kZSB8fCAhaXNFbGVtZW50KHBhcmVudE5vZGUpIHx8IGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZSQxKHBhcmVudE5vZGUpLnBvc2l0aW9uID09PSAnZml4ZWQnIHx8IGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihwYXJlbnROb2RlLCBzdG9wTm9kZSk7XG59XG5cbi8vIEEgXCJjbGlwcGluZyBhbmNlc3RvclwiIGlzIGFuIGBvdmVyZmxvd2AgZWxlbWVudCB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgY2hpbGQgZWxlbWVudHMuIFRoaXMgcmV0dXJucyBhbGwgY2xpcHBpbmcgYW5jZXN0b3JzXG4vLyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCB1cCB0aGUgdHJlZS5cbmZ1bmN0aW9uIGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyhlbGVtZW50LCBjYWNoZSkge1xuICBjb25zdCBjYWNoZWRSZXN1bHQgPSBjYWNoZS5nZXQoZWxlbWVudCk7XG4gIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICB9XG4gIGxldCByZXN1bHQgPSBnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50LCBbXSwgZmFsc2UpLmZpbHRlcihlbCA9PiBpc0VsZW1lbnQoZWwpICYmIGdldE5vZGVOYW1lKGVsKSAhPT0gJ2JvZHknKTtcbiAgbGV0IGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgY29uc3QgZWxlbWVudElzRml4ZWQgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCc7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgd2hpbGUgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGN1cnJlbnROb2RlKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlzQ29udGFpbmluZyA9IGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKTtcbiAgICBpZiAoIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkRHJvcEN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIDogIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnICYmICEhY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgJiYgYWJzb2x1dGVPckZpeGVkLmhhcyhjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZS5wb3NpdGlvbikgfHwgaXNPdmVyZmxvd0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgY3VycmVudE5vZGUpO1xuICAgIGlmIChzaG91bGREcm9wQ3VycmVudE5vZGUpIHtcbiAgICAgIC8vIERyb3Agbm9uLWNvbnRhaW5pbmcgYmxvY2tzLlxuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihhbmNlc3RvciA9PiBhbmNlc3RvciAhPT0gY3VycmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWNvcmQgbGFzdCBjb250YWluaW5nIGJsb2NrIGZvciBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICBjYWNoZS5zZXQoZWxlbWVudCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBpc1RvcExheWVyKGVsZW1lbnQpID8gW10gOiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgdGhpcy5fYykgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5lbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMsIHJvb3RCb3VuZGFyeV07XG4gIGNvbnN0IGZpcnN0Q2xpcHBpbmdBbmNlc3RvciA9IGNsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ0FuY2VzdG9ycy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nQW5jZXN0b3IpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGVsZW1lbnQsIG9mZnNldFBhcmVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBpc0ZpeGVkID0gc3RyYXRlZ3kgPT09ICdmaXhlZCc7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuXG4gIC8vIElmIHRoZSA8Ym9keT4gc2Nyb2xsYmFyIGFwcGVhcnMgb24gdGhlIGxlZnQgKGUuZy4gUlRMIHN5c3RlbXMpLiBVc2VcbiAgLy8gRmlyZWZveCB3aXRoIGxheW91dC5zY3JvbGxiYXIuc2lkZSA9IDMgaW4gYWJvdXQ6Y29uZmlnIHRvIHRlc3QgdGhpcy5cbiAgZnVuY3Rpb24gc2V0TGVmdFJUTFNjcm9sbGJhck9mZnNldCgpIHtcbiAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gIH1cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlLCBpc0ZpeGVkLCBvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBzZXRMZWZ0UlRMU2Nyb2xsYmFyT2Zmc2V0KCk7XG4gICAgfVxuICB9XG4gIGlmIChpc0ZpeGVkICYmICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiBkb2N1bWVudEVsZW1lbnQpIHtcbiAgICBzZXRMZWZ0UlRMU2Nyb2xsYmFyT2Zmc2V0KCk7XG4gIH1cbiAgY29uc3QgaHRtbE9mZnNldCA9IGRvY3VtZW50RWxlbWVudCAmJiAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQgPyBnZXRIVE1MT2Zmc2V0KGRvY3VtZW50RWxlbWVudCwgc2Nyb2xsKSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgY29uc3QgeCA9IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54IC0gaHRtbE9mZnNldC54O1xuICBjb25zdCB5ID0gcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55IC0gaHRtbE9mZnNldC55O1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljUG9zaXRpb25lZChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnO1xufVxuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocG9seWZpbGwpIHtcbiAgICByZXR1cm4gcG9seWZpbGwoZWxlbWVudCk7XG4gIH1cbiAgbGV0IHJhd09mZnNldFBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuXG4gIC8vIEZpcmVmb3ggcmV0dXJucyB0aGUgPGh0bWw+IGVsZW1lbnQgYXMgdGhlIG9mZnNldFBhcmVudCBpZiBpdCdzIG5vbi1zdGF0aWMsXG4gIC8vIHdoaWxlIENocm9tZSBhbmQgU2FmYXJpIHJldHVybiB0aGUgPGJvZHk+IGVsZW1lbnQuIFRoZSA8Ym9keT4gZWxlbWVudCBtdXN0XG4gIC8vIGJlIHVzZWQgdG8gcGVyZm9ybSB0aGUgY29ycmVjdCBjYWxjdWxhdGlvbnMgZXZlbiBpZiB0aGUgPGh0bWw+IGVsZW1lbnQgaXNcbiAgLy8gbm9uLXN0YXRpYy5cbiAgaWYgKGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSA9PT0gcmF3T2Zmc2V0UGFyZW50KSB7XG4gICAgcmF3T2Zmc2V0UGFyZW50ID0gcmF3T2Zmc2V0UGFyZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuICByZXR1cm4gcmF3T2Zmc2V0UGFyZW50O1xufVxuXG4vLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKGlzVG9wTGF5ZXIoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gd2luO1xuICB9XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIGxldCBzdmdPZmZzZXRQYXJlbnQgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICAgIHdoaWxlIChzdmdPZmZzZXRQYXJlbnQgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShzdmdPZmZzZXRQYXJlbnQpKSB7XG4gICAgICBpZiAoaXNFbGVtZW50KHN2Z09mZnNldFBhcmVudCkgJiYgIWlzU3RhdGljUG9zaXRpb25lZChzdmdPZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBzdmdPZmZzZXRQYXJlbnQ7XG4gICAgICB9XG4gICAgICBzdmdPZmZzZXRQYXJlbnQgPSBnZXRQYXJlbnROb2RlKHN2Z09mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiB3aW47XG4gIH1cbiAgbGV0IG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpO1xuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCwgcG9seWZpbGwpO1xuICB9XG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgaXNMYXN0VHJhdmVyc2FibGVOb2RlKG9mZnNldFBhcmVudCkgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkgJiYgIWlzQ29udGFpbmluZ0Jsb2NrKG9mZnNldFBhcmVudCkpIHtcbiAgICByZXR1cm4gd2luO1xuICB9XG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbjtcbn1cblxuY29uc3QgZ2V0RWxlbWVudFJlY3RzID0gYXN5bmMgZnVuY3Rpb24gKGRhdGEpIHtcbiAgY29uc3QgZ2V0T2Zmc2V0UGFyZW50Rm4gPSB0aGlzLmdldE9mZnNldFBhcmVudCB8fCBnZXRPZmZzZXRQYXJlbnQ7XG4gIGNvbnN0IGdldERpbWVuc2lvbnNGbiA9IHRoaXMuZ2V0RGltZW5zaW9ucztcbiAgY29uc3QgZmxvYXRpbmdEaW1lbnNpb25zID0gYXdhaXQgZ2V0RGltZW5zaW9uc0ZuKGRhdGEuZmxvYXRpbmcpO1xuICByZXR1cm4ge1xuICAgIHJlZmVyZW5jZTogZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZGF0YS5yZWZlcmVuY2UsIGF3YWl0IGdldE9mZnNldFBhcmVudEZuKGRhdGEuZmxvYXRpbmcpLCBkYXRhLnN0cmF0ZWd5KSxcbiAgICBmbG9hdGluZzoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogZmxvYXRpbmdEaW1lbnNpb25zLndpZHRoLFxuICAgICAgaGVpZ2h0OiBmbG9hdGluZ0RpbWVuc2lvbnMuaGVpZ2h0XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gaXNSVEwoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG59XG5cbmNvbnN0IHBsYXRmb3JtID0ge1xuICBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCxcbiAgZ2V0RG9jdW1lbnRFbGVtZW50LFxuICBnZXRDbGlwcGluZ1JlY3QsXG4gIGdldE9mZnNldFBhcmVudCxcbiAgZ2V0RWxlbWVudFJlY3RzLFxuICBnZXRDbGllbnRSZWN0cyxcbiAgZ2V0RGltZW5zaW9ucyxcbiAgZ2V0U2NhbGUsXG4gIGlzRWxlbWVudCxcbiAgaXNSVExcbn07XG5cbmZ1bmN0aW9uIHJlY3RzQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnkgJiYgYS53aWR0aCA9PT0gYi53aWR0aCAmJiBhLmhlaWdodCA9PT0gYi5oZWlnaHQ7XG59XG5cbi8vIGh0dHBzOi8vc2FtdGhvci5hdS8yMDIxL29ic2VydmluZy1kb20vXG5mdW5jdGlvbiBvYnNlcnZlTW92ZShlbGVtZW50LCBvbk1vdmUpIHtcbiAgbGV0IGlvID0gbnVsbDtcbiAgbGV0IHRpbWVvdXRJZDtcbiAgY29uc3Qgcm9vdCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICB2YXIgX2lvO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIChfaW8gPSBpbykgPT0gbnVsbCB8fCBfaW8uZGlzY29ubmVjdCgpO1xuICAgIGlvID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiByZWZyZXNoKHNraXAsIHRocmVzaG9sZCkge1xuICAgIGlmIChza2lwID09PSB2b2lkIDApIHtcbiAgICAgIHNraXAgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJlc2hvbGQgPSAxO1xuICAgIH1cbiAgICBjbGVhbnVwKCk7XG4gICAgY29uc3QgZWxlbWVudFJlY3RGb3JSb290TWFyZ2luID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZWxlbWVudFJlY3RGb3JSb290TWFyZ2luO1xuICAgIGlmICghc2tpcCkge1xuICAgICAgb25Nb3ZlKCk7XG4gICAgfVxuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnNldFRvcCA9IGZsb29yKHRvcCk7XG4gICAgY29uc3QgaW5zZXRSaWdodCA9IGZsb29yKHJvb3QuY2xpZW50V2lkdGggLSAobGVmdCArIHdpZHRoKSk7XG4gICAgY29uc3QgaW5zZXRCb3R0b20gPSBmbG9vcihyb290LmNsaWVudEhlaWdodCAtICh0b3AgKyBoZWlnaHQpKTtcbiAgICBjb25zdCBpbnNldExlZnQgPSBmbG9vcihsZWZ0KTtcbiAgICBjb25zdCByb290TWFyZ2luID0gLWluc2V0VG9wICsgXCJweCBcIiArIC1pbnNldFJpZ2h0ICsgXCJweCBcIiArIC1pbnNldEJvdHRvbSArIFwicHggXCIgKyAtaW5zZXRMZWZ0ICsgXCJweFwiO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICByb290TWFyZ2luLFxuICAgICAgdGhyZXNob2xkOiBtYXgoMCwgbWluKDEsIHRocmVzaG9sZCkpIHx8IDFcbiAgICB9O1xuICAgIGxldCBpc0ZpcnN0VXBkYXRlID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBoYW5kbGVPYnNlcnZlKGVudHJpZXMpIHtcbiAgICAgIGNvbnN0IHJhdGlvID0gZW50cmllc1swXS5pbnRlcnNlY3Rpb25SYXRpbztcbiAgICAgIGlmIChyYXRpbyAhPT0gdGhyZXNob2xkKSB7XG4gICAgICAgIGlmICghaXNGaXJzdFVwZGF0ZSkge1xuICAgICAgICAgIHJldHVybiByZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYXRpbykge1xuICAgICAgICAgIC8vIElmIHRoZSByZWZlcmVuY2UgaXMgY2xpcHBlZCwgdGhlIHJhdGlvIGlzIDAuIFRocm90dGxlIHRoZSByZWZyZXNoXG4gICAgICAgICAgLy8gdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIHVwZGF0ZXMuXG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZWZyZXNoKGZhbHNlLCAxZS03KTtcbiAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZyZXNoKGZhbHNlLCByYXRpbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyYXRpbyA9PT0gMSAmJiAhcmVjdHNBcmVFcXVhbChlbGVtZW50UmVjdEZvclJvb3RNYXJnaW4sIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpKSB7XG4gICAgICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCBldmVuIHRob3VnaCB0aGUgcmF0aW8gaXMgcmVwb3J0ZWQgYXMgMSwgdGhlXG4gICAgICAgIC8vIGVsZW1lbnQgaXMgbm90IGFjdHVhbGx5IGZ1bGx5IHdpdGhpbiB0aGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIncyByb290XG4gICAgICAgIC8vIGFyZWEgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIHVuZGVyIHBlcmZvcm1hbmNlIGNvbnN0cmFpbnRzLiBUaGlzIG1heVxuICAgICAgICAvLyBiZSBhIGJ1ZyBpbiB0aGUgYnJvd3NlcidzIEludGVyc2VjdGlvbk9ic2VydmVyIGltcGxlbWVudGF0aW9uLiBUb1xuICAgICAgICAvLyB3b3JrIGFyb3VuZCB0aGlzLCB3ZSBjb21wYXJlIHRoZSBlbGVtZW50J3MgYm91bmRpbmcgcmVjdCBub3cgd2l0aFxuICAgICAgICAvLyB3aGF0IGl0IHdhcyBhdCB0aGUgdGltZSB3ZSBjcmVhdGVkIHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlci4gSWYgdGhleVxuICAgICAgICAvLyBhcmUgbm90IGVxdWFsIHRoZW4gdGhlIGVsZW1lbnQgbW92ZWQsIHNvIHdlIHJlZnJlc2guXG4gICAgICAgIHJlZnJlc2goKTtcbiAgICAgIH1cbiAgICAgIGlzRmlyc3RVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBPbGRlciBicm93c2VycyBkb24ndCBzdXBwb3J0IGEgYGRvY3VtZW50YCBhcyB0aGUgcm9vdCBhbmQgd2lsbCB0aHJvdyBhblxuICAgIC8vIGVycm9yLlxuICAgIHRyeSB7XG4gICAgICBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVPYnNlcnZlLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC8vIEhhbmRsZSA8aWZyYW1lPnNcbiAgICAgICAgcm9vdDogcm9vdC5vd25lckRvY3VtZW50XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlvLm9ic2VydmUoZWxlbWVudCk7XG4gIH1cbiAgcmVmcmVzaCh0cnVlKTtcbiAgcmV0dXJuIGNsZWFudXA7XG59XG5cbi8qKlxuICogQXV0b21hdGljYWxseSB1cGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIG5lY2Vzc2FyeS5cbiAqIFNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG1vdW50ZWQgb24gdGhlIERPTSBvclxuICogdmlzaWJsZSBvbiB0aGUgc2NyZWVuLlxuICogQHJldHVybnMgY2xlYW51cCBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBpbnZva2VkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXNcbiAqIHJlbW92ZWQgZnJvbSB0aGUgRE9NIG9yIGhpZGRlbiBmcm9tIHRoZSBzY3JlZW4uXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1VwZGF0ZVxuICovXG5mdW5jdGlvbiBhdXRvVXBkYXRlKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHVwZGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBhbmNlc3RvclNjcm9sbCA9IHRydWUsXG4gICAgYW5jZXN0b3JSZXNpemUgPSB0cnVlLFxuICAgIGVsZW1lbnRSZXNpemUgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgbGF5b3V0U2hpZnQgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgYW5pbWF0aW9uRnJhbWUgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVmZXJlbmNlRWwgPSB1bndyYXBFbGVtZW50KHJlZmVyZW5jZSk7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IGFuY2VzdG9yU2Nyb2xsIHx8IGFuY2VzdG9yUmVzaXplID8gWy4uLihyZWZlcmVuY2VFbCA/IGdldE92ZXJmbG93QW5jZXN0b3JzKHJlZmVyZW5jZUVsKSA6IFtdKSwgLi4uZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZmxvYXRpbmcpXSA6IFtdO1xuICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgfSk7XG4gIGNvbnN0IGNsZWFudXBJbyA9IHJlZmVyZW5jZUVsICYmIGxheW91dFNoaWZ0ID8gb2JzZXJ2ZU1vdmUocmVmZXJlbmNlRWwsIHVwZGF0ZSkgOiBudWxsO1xuICBsZXQgcmVvYnNlcnZlRnJhbWUgPSAtMTtcbiAgbGV0IHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgaWYgKGVsZW1lbnRSZXNpemUpIHtcbiAgICByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihfcmVmID0+IHtcbiAgICAgIGxldCBbZmlyc3RFbnRyeV0gPSBfcmVmO1xuICAgICAgaWYgKGZpcnN0RW50cnkgJiYgZmlyc3RFbnRyeS50YXJnZXQgPT09IHJlZmVyZW5jZUVsICYmIHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIC8vIFByZXZlbnQgdXBkYXRlIGxvb3BzIHdoZW4gdXNpbmcgdGhlIGBzaXplYCBtaWRkbGV3YXJlLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzE3NDBcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVvYnNlcnZlRnJhbWUpO1xuICAgICAgICByZW9ic2VydmVGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgdmFyIF9yZXNpemVPYnNlcnZlcjtcbiAgICAgICAgICAoX3Jlc2l6ZU9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgfHwgX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH0pO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiAhYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUocmVmZXJlbmNlRWwpO1xuICAgIH1cbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgfVxuICBsZXQgZnJhbWVJZDtcbiAgbGV0IHByZXZSZWZSZWN0ID0gYW5pbWF0aW9uRnJhbWUgPyBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKSA6IG51bGw7XG4gIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgIGZyYW1lTG9vcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGZyYW1lTG9vcCgpIHtcbiAgICBjb25zdCBuZXh0UmVmUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpO1xuICAgIGlmIChwcmV2UmVmUmVjdCAmJiAhcmVjdHNBcmVFcXVhbChwcmV2UmVmUmVjdCwgbmV4dFJlZlJlY3QpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gICAgcHJldlJlZlJlY3QgPSBuZXh0UmVmUmVjdDtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cbiAgdXBkYXRlKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIF9yZXNpemVPYnNlcnZlcjI7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlKTtcbiAgICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgY2xlYW51cElvID09IG51bGwgfHwgY2xlYW51cElvKCk7XG4gICAgKF9yZXNpemVPYnNlcnZlcjIgPSByZXNpemVPYnNlcnZlcikgPT0gbnVsbCB8fCBfcmVzaXplT2JzZXJ2ZXIyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5IG9uIGVhY2ggc2lkZS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5jb25zdCBkZXRlY3RPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93JDE7XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHBsYWNlbWVudCBieSB0cmFuc2xhdGluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCBhbG9uZyB0aGVcbiAqIHNwZWNpZmllZCBheGVzLlxuICogQSBudW1iZXIgKHNob3J0aGFuZCBmb3IgYG1haW5BeGlzYCBvciBkaXN0YW5jZSksIG9yIGFuIGF4ZXMgY29uZmlndXJhdGlvblxuICogb2JqZWN0IG1heSBiZSBwYXNzZWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cbmNvbnN0IG9mZnNldCA9IG9mZnNldCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGF1dG9QbGFjZW1lbnQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gc2hpZnQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmbGlwJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0aGF0IGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IOKAlFxuICogZm9yIGluc3RhbmNlLCBwcmV2ZW50IGl0IGZyb20gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5IG9yIG1hdGNoIHRoZVxuICogd2lkdGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NpemVcbiAqL1xuY29uc3Qgc2l6ZSA9IHNpemUkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBoaWRlJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gYXJyb3ckMTtcblxuLyoqXG4gKiBQcm92aWRlcyBpbXByb3ZlZCBwb3NpdGlvbmluZyBmb3IgaW5saW5lIHJlZmVyZW5jZSBlbGVtZW50cyB0aGF0IGNhbiBzcGFuXG4gKiBvdmVyIG11bHRpcGxlIGxpbmVzLCBzdWNoIGFzIGh5cGVybGlua3Mgb3IgcmFuZ2Ugc2VsZWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbmxpbmVcbiAqL1xuY29uc3QgaW5saW5lID0gaW5saW5lJDE7XG5cbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBsaW1pdFNoaWZ0JDE7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIGdpdmVuIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSAocmVmZXJlbmNlLCBmbG9hdGluZywgb3B0aW9ucykgPT4ge1xuICAvLyBUaGlzIGNhY2hlcyB0aGUgZXhwZW5zaXZlIGBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnNgIGZ1bmN0aW9uIHNvIHRoYXRcbiAgLy8gbXVsdGlwbGUgbGlmZWN5Y2xlIHJlc2V0cyByZS11c2UgdGhlIHNhbWUgcmVzdWx0LiBJdCBvbmx5IGxpdmVzIGZvciBhXG4gIC8vIHNpbmdsZSBjYWxsLiBJZiBvdGhlciBmdW5jdGlvbnMgYmVjb21lIGV4cGVuc2l2ZSwgd2UgY2FuIGFkZCB0aGVtIGFzIHdlbGwuXG4gIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0ge1xuICAgIHBsYXRmb3JtLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3QgcGxhdGZvcm1XaXRoQ2FjaGUgPSB7XG4gICAgLi4ubWVyZ2VkT3B0aW9ucy5wbGF0Zm9ybSxcbiAgICBfYzogY2FjaGVcbiAgfTtcbiAgcmV0dXJuIGNvbXB1dGVQb3NpdGlvbiQxKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLFxuICAgIHBsYXRmb3JtOiBwbGF0Zm9ybVdpdGhDYWNoZVxuICB9KTtcbn07XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcGxhdGZvcm0sIHNoaWZ0LCBzaXplIH07XG4iXSwibmFtZXMiOlsicmVjdFRvQ2xpZW50UmVjdCIsImFycm93IiwiYXJyb3ckMSIsImF1dG9QbGFjZW1lbnQiLCJhdXRvUGxhY2VtZW50JDEiLCJkZXRlY3RPdmVyZmxvdyIsImRldGVjdE92ZXJmbG93JDEiLCJmbGlwIiwiZmxpcCQxIiwiaGlkZSIsImhpZGUkMSIsImlubGluZSIsImlubGluZSQxIiwibGltaXRTaGlmdCIsImxpbWl0U2hpZnQkMSIsIm9mZnNldCIsIm9mZnNldCQxIiwic2hpZnQiLCJzaGlmdCQxIiwic2l6ZSIsInNpemUkMSIsImNvbXB1dGVQb3NpdGlvbiIsImNvbXB1dGVQb3NpdGlvbiQxIiwicm91bmQiLCJjcmVhdGVDb29yZHMiLCJtYXgiLCJtaW4iLCJmbG9vciIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlJDEiLCJpc0hUTUxFbGVtZW50IiwiaXNFbGVtZW50IiwiZ2V0V2luZG93IiwiaXNXZWJLaXQiLCJnZXRGcmFtZUVsZW1lbnQiLCJnZXROb2RlU2Nyb2xsIiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiaXNUb3BMYXllciIsImdldE5vZGVOYW1lIiwiaXNPdmVyZmxvd0VsZW1lbnQiLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsImdldFBhcmVudE5vZGUiLCJpc0xhc3RUcmF2ZXJzYWJsZU5vZGUiLCJpc0NvbnRhaW5pbmdCbG9jayIsImlzVGFibGVFbGVtZW50IiwiZ2V0Q29udGFpbmluZ0Jsb2NrIiwiZ2V0Q3NzRGltZW5zaW9ucyIsImVsZW1lbnQiLCJjc3MiLCJ3aWR0aCIsInBhcnNlRmxvYXQiLCJoZWlnaHQiLCJoYXNPZmZzZXQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsInNob3VsZEZhbGxiYWNrIiwiJCIsInVud3JhcEVsZW1lbnQiLCJjb250ZXh0RWxlbWVudCIsImdldFNjYWxlIiwiZG9tRWxlbWVudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ4IiwieSIsIk51bWJlciIsImlzRmluaXRlIiwibm9PZmZzZXRzIiwiZ2V0VmlzdWFsT2Zmc2V0cyIsIndpbiIsInZpc3VhbFZpZXdwb3J0Iiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsInNob3VsZEFkZFZpc3VhbE9mZnNldHMiLCJpc0ZpeGVkIiwiZmxvYXRpbmdPZmZzZXRQYXJlbnQiLCJpbmNsdWRlU2NhbGUiLCJpc0ZpeGVkU3RyYXRlZ3kiLCJvZmZzZXRQYXJlbnQiLCJjbGllbnRSZWN0Iiwic2NhbGUiLCJ2aXN1YWxPZmZzZXRzIiwibGVmdCIsInRvcCIsIm9mZnNldFdpbiIsImN1cnJlbnRXaW4iLCJjdXJyZW50SUZyYW1lIiwiaWZyYW1lU2NhbGUiLCJpZnJhbWVSZWN0IiwiY2xpZW50TGVmdCIsInBhZGRpbmdMZWZ0IiwiY2xpZW50VG9wIiwicGFkZGluZ1RvcCIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJsZWZ0U2Nyb2xsIiwic2Nyb2xsTGVmdCIsImdldEhUTUxPZmZzZXQiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGwiLCJodG1sUmVjdCIsInNjcm9sbFRvcCIsImNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0IiwiX3JlZiIsImVsZW1lbnRzIiwic3RyYXRlZ3kiLCJ0b3BMYXllciIsImZsb2F0aW5nIiwib2Zmc2V0cyIsImlzT2Zmc2V0UGFyZW50QW5FbGVtZW50Iiwib2Zmc2V0UmVjdCIsImh0bWxPZmZzZXQiLCJnZXRDbGllbnRSZWN0cyIsIkFycmF5IiwiZnJvbSIsImdldERvY3VtZW50UmVjdCIsImh0bWwiLCJib2R5Iiwib3duZXJEb2N1bWVudCIsInNjcm9sbFdpZHRoIiwiY2xpZW50V2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJkaXJlY3Rpb24iLCJTQ1JPTExCQVJfTUFYIiwiZ2V0Vmlld3BvcnRSZWN0IiwidmlzdWFsVmlld3BvcnRCYXNlZCIsIndpbmRvd1Njcm9sbGJhclgiLCJkb2MiLCJib2R5U3R5bGVzIiwiYm9keU1hcmdpbklubGluZSIsImNvbXBhdE1vZGUiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJjbGlwcGluZ1N0YWJsZVNjcm9sbGJhcldpZHRoIiwiTWF0aCIsImFicyIsImFic29sdXRlT3JGaXhlZCIsIlNldCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yIiwiY2xpcHBpbmdBbmNlc3RvciIsImhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvciIsInN0b3BOb2RlIiwicGFyZW50Tm9kZSIsInBvc2l0aW9uIiwiZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzIiwiY2FjaGUiLCJjYWNoZWRSZXN1bHQiLCJnZXQiLCJyZXN1bHQiLCJmaWx0ZXIiLCJlbCIsImN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIiwiZWxlbWVudElzRml4ZWQiLCJjdXJyZW50Tm9kZSIsImNvbXB1dGVkU3R5bGUiLCJjdXJyZW50Tm9kZUlzQ29udGFpbmluZyIsInNob3VsZERyb3BDdXJyZW50Tm9kZSIsImhhcyIsImFuY2VzdG9yIiwic2V0IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJlbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMiLCJfYyIsImNvbmNhdCIsImNsaXBwaW5nQW5jZXN0b3JzIiwiZmlyc3RDbGlwcGluZ0FuY2VzdG9yIiwiY2xpcHBpbmdSZWN0IiwicmVkdWNlIiwiYWNjUmVjdCIsInJpZ2h0IiwiYm90dG9tIiwiZ2V0RGltZW5zaW9ucyIsImdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50Iiwic2V0TGVmdFJUTFNjcm9sbGJhck9mZnNldCIsImlzU3RhdGljUG9zaXRpb25lZCIsImdldFRydWVPZmZzZXRQYXJlbnQiLCJwb2x5ZmlsbCIsInJhd09mZnNldFBhcmVudCIsImdldE9mZnNldFBhcmVudCIsInN2Z09mZnNldFBhcmVudCIsImdldEVsZW1lbnRSZWN0cyIsImRhdGEiLCJnZXRPZmZzZXRQYXJlbnRGbiIsImdldERpbWVuc2lvbnNGbiIsImZsb2F0aW5nRGltZW5zaW9ucyIsInJlZmVyZW5jZSIsImlzUlRMIiwicGxhdGZvcm0iLCJyZWN0c0FyZUVxdWFsIiwiYSIsImIiLCJvYnNlcnZlTW92ZSIsIm9uTW92ZSIsImlvIiwidGltZW91dElkIiwicm9vdCIsImNsZWFudXAiLCJfaW8iLCJjbGVhclRpbWVvdXQiLCJkaXNjb25uZWN0IiwicmVmcmVzaCIsInNraXAiLCJ0aHJlc2hvbGQiLCJlbGVtZW50UmVjdEZvclJvb3RNYXJnaW4iLCJpbnNldFRvcCIsImluc2V0UmlnaHQiLCJpbnNldEJvdHRvbSIsImluc2V0TGVmdCIsInJvb3RNYXJnaW4iLCJvcHRpb25zIiwiaXNGaXJzdFVwZGF0ZSIsImhhbmRsZU9ic2VydmUiLCJlbnRyaWVzIiwicmF0aW8iLCJpbnRlcnNlY3Rpb25SYXRpbyIsInNldFRpbWVvdXQiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIl9vYmplY3RTcHJlYWQiLCJfZSIsIm9ic2VydmUiLCJhdXRvVXBkYXRlIiwidXBkYXRlIiwiYW5jZXN0b3JTY3JvbGwiLCJhbmNlc3RvclJlc2l6ZSIsImVsZW1lbnRSZXNpemUiLCJSZXNpemVPYnNlcnZlciIsImxheW91dFNoaWZ0IiwiYW5pbWF0aW9uRnJhbWUiLCJyZWZlcmVuY2VFbCIsImFuY2VzdG9ycyIsImZvckVhY2giLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsImNsZWFudXBJbyIsInJlb2JzZXJ2ZUZyYW1lIiwicmVzaXplT2JzZXJ2ZXIiLCJmaXJzdEVudHJ5IiwidGFyZ2V0IiwidW5vYnNlcnZlIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJfcmVzaXplT2JzZXJ2ZXIiLCJmcmFtZUlkIiwicHJldlJlZlJlY3QiLCJmcmFtZUxvb3AiLCJuZXh0UmVmUmVjdCIsIl9yZXNpemVPYnNlcnZlcjIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiTWFwIiwibWVyZ2VkT3B0aW9ucyIsInBsYXRmb3JtV2l0aENhY2hlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.platform),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   useFloating: () => (/* binding */ useFloating)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\n\nvar isClient = typeof document !== 'undefined';\nvar noop = function noop() {};\nvar index = isClient ? react__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect : noop;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length;\n  let i;\n  let keys;\n  if (a && b && typeof a === 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\nfunction getDPR(element) {\n  if (true) {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\nfunction useLatestRef(value) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = react__WEBPACK_IMPORTED_MODULE_2__.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_2__.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);\n  const [_floating, _setFloating] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);\n  const setReference = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(node => {\n    if (node !== referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(node => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n  const floatingRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n  const dataRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(data);\n  const hasWhileElementsMounted = whileElementsMounted != null;\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const openRef = useLatestRef(open);\n  const update = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition)(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = _objectSpread(_objectSpread({}, data), {}, {\n        // The floating element's position may be recomputed while it's closed\n        // but still mounted (such as when transitioning out). To ensure\n        // `isPositioned` will be `false` initially on the next open, avoid\n        // setting it to `true` when `open === false` (must be specified).\n        isPositioned: openRef.current !== false\n      });\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        react_dom__WEBPACK_IMPORTED_MODULE_3__.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef, openRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => _objectSpread(_objectSpread({}, data), {}, {\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      }\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  const refs = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return _objectSpread(_objectSpread({}, initialStyles), {}, {\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\"\n      }, getDPR(elements.floating) >= 1.5 && {\n        willChange: 'transform'\n      });\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => _objectSpread(_objectSpread({}, data), {}, {\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow$1 = options => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === 'function' ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      }\n      if (element) {\n        return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.offset)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.hide)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = (options, deps) => _objectSpread(_objectSpread({}, (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.inline)(options)), {}, {\n  options: [options, deps]\n});\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = (options, deps) => _objectSpread(_objectSpread({}, arrow$1(options)), {}, {\n  options: [options, deps]\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZPO0FBQzlIO0FBQ2hGO0FBQ1M7QUFDRjtBQUV0QyxJQUFJMEIsUUFBUSxHQUFHLE9BQU9DLFFBQVEsS0FBSyxXQUFXO0FBRTlDLElBQUlDLElBQUksR0FBRyxTQUFTQSxJQUFJQSxDQUFBLEVBQUcsQ0FBQyxDQUFDO0FBQzdCLElBQUlDLEtBQUssR0FBR0gsUUFBUSxHQUFHRixrREFBZSxHQUFHSSxJQUFJOztBQUU3QztBQUNBO0FBQ0EsU0FBU0UsU0FBU0EsQ0FBQ0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7RUFDdkIsSUFBSUQsQ0FBQyxLQUFLQyxDQUFDLEVBQUU7SUFDWCxPQUFPLElBQUk7RUFDYjtFQUNBLElBQUksT0FBT0QsQ0FBQyxLQUFLLE9BQU9DLENBQUMsRUFBRTtJQUN6QixPQUFPLEtBQUs7RUFDZDtFQUNBLElBQUksT0FBT0QsQ0FBQyxLQUFLLFVBQVUsSUFBSUEsQ0FBQyxDQUFDRSxRQUFRLENBQUMsQ0FBQyxLQUFLRCxDQUFDLENBQUNDLFFBQVEsQ0FBQyxDQUFDLEVBQUU7SUFDNUQsT0FBTyxJQUFJO0VBQ2I7RUFDQSxJQUFJQyxNQUFNO0VBQ1YsSUFBSUMsQ0FBQztFQUNMLElBQUlDLElBQUk7RUFDUixJQUFJTCxDQUFDLElBQUlDLENBQUMsSUFBSSxPQUFPRCxDQUFDLEtBQUssUUFBUSxFQUFFO0lBQ25DLElBQUlNLEtBQUssQ0FBQ0MsT0FBTyxDQUFDUCxDQUFDLENBQUMsRUFBRTtNQUNwQkcsTUFBTSxHQUFHSCxDQUFDLENBQUNHLE1BQU07TUFDakIsSUFBSUEsTUFBTSxLQUFLRixDQUFDLENBQUNFLE1BQU0sRUFBRSxPQUFPLEtBQUs7TUFDckMsS0FBS0MsQ0FBQyxHQUFHRCxNQUFNLEVBQUVDLENBQUMsRUFBRSxLQUFLLENB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QTtBQUNBO0FBQ0E7QUFDQSxNQUFNdkgsS0FBSyxHQUFHQSxDQUFDNEQsT0FBTyxFQUFFMkQsSUFBSSxLQUFBakIsYUFBQSxDQUFBQSxhQUFBLEtBQ3ZCVyxPQUFPLENBQUNyRCxPQUFPLENBQUM7RUFDbkJBLE9BQU8sRUFBRSxDQUFDQSxPQUFPLEVBQUUyRCxJQUFJO0FBQUMsRUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYWNoYWNrcy1ob21lcGFnZS8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvcmVhY3QtZG9tL2Rpc3QvZmxvYXRpbmctdWkucmVhY3QtZG9tLm1qcz9jNzlkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbXB1dGVQb3NpdGlvbiwgYXJyb3cgYXMgYXJyb3ckMiwgYXV0b1BsYWNlbWVudCBhcyBhdXRvUGxhY2VtZW50JDEsIGZsaXAgYXMgZmxpcCQxLCBoaWRlIGFzIGhpZGUkMSwgaW5saW5lIGFzIGlubGluZSQxLCBsaW1pdFNoaWZ0IGFzIGxpbWl0U2hpZnQkMSwgb2Zmc2V0IGFzIG9mZnNldCQxLCBzaGlmdCBhcyBzaGlmdCQxLCBzaXplIGFzIHNpemUkMSB9IGZyb20gJ0BmbG9hdGluZy11aS9kb20nO1xuZXhwb3J0IHsgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIHBsYXRmb3JtIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG52YXIgaXNDbGllbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbnZhciBpbmRleCA9IGlzQ2xpZW50ID8gdXNlTGF5b3V0RWZmZWN0IDogbm9vcDtcblxuLy8gRm9yayBvZiBgZmFzdC1kZWVwLWVxdWFsYCB0aGF0IG9ubHkgZG9lcyB0aGUgY29tcGFyaXNvbnMgd2UgbmVlZCBhbmQgY29tcGFyZXNcbi8vIGZ1bmN0aW9uc1xuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyAmJiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGxldCBsZW5ndGg7XG4gIGxldCBpO1xuICBsZXQga2V5cztcbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChrZXkgPT09ICdfb3duZXInICYmIGEuJCR0eXBlb2YpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xufVxuXG5mdW5jdGlvbiBnZXREUFIoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBjb25zdCB3aW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICByZXR1cm4gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbn1cblxuZnVuY3Rpb24gcm91bmRCeURQUihlbGVtZW50LCB2YWx1ZSkge1xuICBjb25zdCBkcHIgPSBnZXREUFIoZWxlbWVudCk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogZHByKSAvIGRwcjtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0UmVmKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGEgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGbG9hdGluZ1xuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm0sXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIHJlZmVyZW5jZTogZXh0ZXJuYWxSZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZzogZXh0ZXJuYWxGbG9hdGluZ1xuICAgIH0gPSB7fSxcbiAgICB0cmFuc2Zvcm0gPSB0cnVlLFxuICAgIHdoaWxlRWxlbWVudHNNb3VudGVkLFxuICAgIG9wZW5cbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IFtkYXRhLCBzZXREYXRhXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgc3RyYXRlZ3ksXG4gICAgcGxhY2VtZW50LFxuICAgIG1pZGRsZXdhcmVEYXRhOiB7fSxcbiAgICBpc1Bvc2l0aW9uZWQ6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBbbGF0ZXN0TWlkZGxld2FyZSwgc2V0TGF0ZXN0TWlkZGxld2FyZV0gPSBSZWFjdC51c2VTdGF0ZShtaWRkbGV3YXJlKTtcbiAgaWYgKCFkZWVwRXF1YWwobGF0ZXN0TWlkZGxld2FyZSwgbWlkZGxld2FyZSkpIHtcbiAgICBzZXRMYXRlc3RNaWRkbGV3YXJlKG1pZGRsZXdhcmUpO1xuICB9XG4gIGNvbnN0IFtfcmVmZXJlbmNlLCBfc2V0UmVmZXJlbmNlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbX2Zsb2F0aW5nLCBfc2V0RmxvYXRpbmddID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChub2RlICE9PSByZWZlcmVuY2VSZWYuY3VycmVudCkge1xuICAgICAgcmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgX3NldFJlZmVyZW5jZShub2RlKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3Qgc2V0RmxvYXRpbmcgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBpZiAobm9kZSAhPT0gZmxvYXRpbmdSZWYuY3VycmVudCkge1xuICAgICAgZmxvYXRpbmdSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBfc2V0RmxvYXRpbmcobm9kZSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHJlZmVyZW5jZUVsID0gZXh0ZXJuYWxSZWZlcmVuY2UgfHwgX3JlZmVyZW5jZTtcbiAgY29uc3QgZmxvYXRpbmdFbCA9IGV4dGVybmFsRmxvYXRpbmcgfHwgX2Zsb2F0aW5nO1xuICBjb25zdCByZWZlcmVuY2VSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGZsb2F0aW5nUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBkYXRhUmVmID0gUmVhY3QudXNlUmVmKGRhdGEpO1xuICBjb25zdCBoYXNXaGlsZUVsZW1lbnRzTW91bnRlZCA9IHdoaWxlRWxlbWVudHNNb3VudGVkICE9IG51bGw7XG4gIGNvbnN0IHdoaWxlRWxlbWVudHNNb3VudGVkUmVmID0gdXNlTGF0ZXN0UmVmKHdoaWxlRWxlbWVudHNNb3VudGVkKTtcbiAgY29uc3QgcGxhdGZvcm1SZWYgPSB1c2VMYXRlc3RSZWYocGxhdGZvcm0pO1xuICBjb25zdCBvcGVuUmVmID0gdXNlTGF0ZXN0UmVmKG9wZW4pO1xuICBjb25zdCB1cGRhdGUgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFyZWZlcmVuY2VSZWYuY3VycmVudCB8fCAhZmxvYXRpbmdSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmU6IGxhdGVzdE1pZGRsZXdhcmVcbiAgICB9O1xuICAgIGlmIChwbGF0Zm9ybVJlZi5jdXJyZW50KSB7XG4gICAgICBjb25maWcucGxhdGZvcm0gPSBwbGF0Zm9ybVJlZi5jdXJyZW50O1xuICAgIH1cbiAgICBjb21wdXRlUG9zaXRpb24ocmVmZXJlbmNlUmVmLmN1cnJlbnQsIGZsb2F0aW5nUmVmLmN1cnJlbnQsIGNvbmZpZykudGhlbihkYXRhID0+IHtcbiAgICAgIGNvbnN0IGZ1bGxEYXRhID0ge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICAvLyBUaGUgZmxvYXRpbmcgZWxlbWVudCdzIHBvc2l0aW9uIG1heSBiZSByZWNvbXB1dGVkIHdoaWxlIGl0J3MgY2xvc2VkXG4gICAgICAgIC8vIGJ1dCBzdGlsbCBtb3VudGVkIChzdWNoIGFzIHdoZW4gdHJhbnNpdGlvbmluZyBvdXQpLiBUbyBlbnN1cmVcbiAgICAgICAgLy8gYGlzUG9zaXRpb25lZGAgd2lsbCBiZSBgZmFsc2VgIGluaXRpYWxseSBvbiB0aGUgbmV4dCBvcGVuLCBhdm9pZFxuICAgICAgICAvLyBzZXR0aW5nIGl0IHRvIGB0cnVlYCB3aGVuIGBvcGVuID09PSBmYWxzZWAgKG11c3QgYmUgc3BlY2lmaWVkKS5cbiAgICAgICAgaXNQb3NpdGlvbmVkOiBvcGVuUmVmLmN1cnJlbnQgIT09IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50ICYmICFkZWVwRXF1YWwoZGF0YVJlZi5jdXJyZW50LCBmdWxsRGF0YSkpIHtcbiAgICAgICAgZGF0YVJlZi5jdXJyZW50ID0gZnVsbERhdGE7XG4gICAgICAgIFJlYWN0RE9NLmZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgc2V0RGF0YShmdWxsRGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbbGF0ZXN0TWlkZGxld2FyZSwgcGxhY2VtZW50LCBzdHJhdGVneSwgcGxhdGZvcm1SZWYsIG9wZW5SZWZdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChvcGVuID09PSBmYWxzZSAmJiBkYXRhUmVmLmN1cnJlbnQuaXNQb3NpdGlvbmVkKSB7XG4gICAgICBkYXRhUmVmLmN1cnJlbnQuaXNQb3NpdGlvbmVkID0gZmFsc2U7XG4gICAgICBzZXREYXRhKGRhdGEgPT4gKHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgaXNQb3NpdGlvbmVkOiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwgW29wZW5dKTtcbiAgY29uc3QgaXNNb3VudGVkUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAocmVmZXJlbmNlRWwpIHJlZmVyZW5jZVJlZi5jdXJyZW50ID0gcmVmZXJlbmNlRWw7XG4gICAgaWYgKGZsb2F0aW5nRWwpIGZsb2F0aW5nUmVmLmN1cnJlbnQgPSBmbG9hdGluZ0VsO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiBmbG9hdGluZ0VsKSB7XG4gICAgICBpZiAod2hpbGVFbGVtZW50c01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm4gd2hpbGVFbGVtZW50c01vdW50ZWRSZWYuY3VycmVudChyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbCwgdXBkYXRlKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgfSwgW3JlZmVyZW5jZUVsLCBmbG9hdGluZ0VsLCB1cGRhdGUsIHdoaWxlRWxlbWVudHNNb3VudGVkUmVmLCBoYXNXaGlsZUVsZW1lbnRzTW91bnRlZF0pO1xuICBjb25zdCByZWZzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlUmVmLFxuICAgIGZsb2F0aW5nOiBmbG9hdGluZ1JlZixcbiAgICBzZXRSZWZlcmVuY2UsXG4gICAgc2V0RmxvYXRpbmdcbiAgfSksIFtzZXRSZWZlcmVuY2UsIHNldEZsb2F0aW5nXSk7XG4gIGNvbnN0IGVsZW1lbnRzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlRWwsXG4gICAgZmxvYXRpbmc6IGZsb2F0aW5nRWxcbiAgfSksIFtyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbF0pO1xuICBjb25zdCBmbG9hdGluZ1N0eWxlcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxTdHlsZXMgPSB7XG4gICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgICBpZiAoIWVsZW1lbnRzLmZsb2F0aW5nKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbFN0eWxlcztcbiAgICB9XG4gICAgY29uc3QgeCA9IHJvdW5kQnlEUFIoZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueCk7XG4gICAgY29uc3QgeSA9IHJvdW5kQnlEUFIoZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueSk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaW5pdGlhbFN0eWxlcyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiLFxuICAgICAgICAuLi4oZ2V0RFBSKGVsZW1lbnRzLmZsb2F0aW5nKSA+PSAxLjUgJiYge1xuICAgICAgICAgIHdpbGxDaGFuZ2U6ICd0cmFuc2Zvcm0nXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgbGVmdDogeCxcbiAgICAgIHRvcDogeVxuICAgIH07XG4gIH0sIFtzdHJhdGVneSwgdHJhbnNmb3JtLCBlbGVtZW50cy5mbG9hdGluZywgZGF0YS54LCBkYXRhLnldKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5kYXRhLFxuICAgIHVwZGF0ZSxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzLFxuICAgIGZsb2F0aW5nU3R5bGVzXG4gIH0pLCBbZGF0YSwgdXBkYXRlLCByZWZzLCBlbGVtZW50cywgZmxvYXRpbmdTdHlsZXNdKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBUaGlzIHdyYXBzIHRoZSBjb3JlIGBhcnJvd2AgbWlkZGxld2FyZSB0byBhbGxvdyBSZWFjdCByZWZzIGFzIHRoZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93JDEgPSBvcHRpb25zID0+IHtcbiAgZnVuY3Rpb24gaXNSZWYodmFsdWUpIHtcbiAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2N1cnJlbnQnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdhcnJvdycsXG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBwYWRkaW5nXG4gICAgICB9ID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zKHN0YXRlKSA6IG9wdGlvbnM7XG4gICAgICBpZiAoZWxlbWVudCAmJiBpc1JlZihlbGVtZW50KSkge1xuICAgICAgICBpZiAoZWxlbWVudC5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYXJyb3ckMih7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LmN1cnJlbnQsXG4gICAgICAgICAgICBwYWRkaW5nXG4gICAgICAgICAgfSkuZm4oc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBhcnJvdyQyKHtcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgfSkuZm4oc3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHBsYWNlbWVudCBieSB0cmFuc2xhdGluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCBhbG9uZyB0aGVcbiAqIHNwZWNpZmllZCBheGVzLlxuICogQSBudW1iZXIgKHNob3J0aGFuZCBmb3IgYG1haW5BeGlzYCBvciBkaXN0YW5jZSksIG9yIGFuIGF4ZXMgY29uZmlndXJhdGlvblxuICogb2JqZWN0IG1heSBiZSBwYXNzZWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cbmNvbnN0IG9mZnNldCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5vZmZzZXQkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLnNoaWZ0JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4ubGltaXRTaGlmdCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBmbGlwcGluZyB0aGUgYHBsYWNlbWVudGBcbiAqIGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIHRoZSBwcmVmZXJyZWQgcGxhY2VtZW50KHMpIHdpbGwgb3ZlcmZsb3cgdGhlXG4gKiBjbGlwcGluZyBib3VuZGFyeS4gQWx0ZXJuYXRpdmUgdG8gYGF1dG9QbGFjZW1lbnRgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5mbGlwJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0aGF0IGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IOKAlFxuICogZm9yIGluc3RhbmNlLCBwcmV2ZW50IGl0IGZyb20gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5IG9yIG1hdGNoIHRoZVxuICogd2lkdGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NpemVcbiAqL1xuY29uc3Qgc2l6ZSA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5zaXplJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGNob29zaW5nIHRoZSBwbGFjZW1lbnRcbiAqIHRoYXQgaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LCB3aXRob3V0IG5lZWRpbmcgdG8gc3BlY2lmeSBhXG4gKiBwcmVmZXJyZWQgcGxhY2VtZW50LiBBbHRlcm5hdGl2ZSB0byBgZmxpcGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1BsYWNlbWVudFxuICovXG5jb25zdCBhdXRvUGxhY2VtZW50ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmF1dG9QbGFjZW1lbnQkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uaGlkZSQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uaW5saW5lJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogVGhpcyB3cmFwcyB0aGUgY29yZSBgYXJyb3dgIG1pZGRsZXdhcmUgdG8gYWxsb3cgUmVhY3QgcmVmcyBhcyB0aGUgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5hcnJvdyQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplLCB1c2VGbG9hdGluZyB9O1xuIl0sIm5hbWVzIjpbImNvbXB1dGVQb3NpdGlvbiIsImFycm93IiwiYXJyb3ckMiIsImF1dG9QbGFjZW1lbnQiLCJhdXRvUGxhY2VtZW50JDEiLCJmbGlwIiwiZmxpcCQxIiwiaGlkZSIsImhpZGUkMSIsImlubGluZSIsImlubGluZSQxIiwibGltaXRTaGlmdCIsImxpbWl0U2hpZnQkMSIsIm9mZnNldCIsIm9mZnNldCQxIiwic2hpZnQiLCJzaGlmdCQxIiwic2l6ZSIsInNpemUkMSIsImF1dG9VcGRhdGUiLCJkZXRlY3RPdmVyZmxvdyIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwicGxhdGZvcm0iLCJSZWFjdCIsInVzZUxheW91dEVmZmVjdCIsIlJlYWN0RE9NIiwiaXNDbGllbnQiLCJkb2N1bWVudCIsIm5vb3AiLCJpbmRleCIsImRlZXBFcXVhbCIsImEiLCJiIiwidG9TdHJpbmciLCJsZW5ndGgiLCJpIiwia2V5cyIsIkFycmF5IiwiaXNBcnJheSIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImtleSIsIiQkdHlwZW9mIiwiZ2V0RFBSIiwiZWxlbWVudCIsIndpbiIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJyb3VuZEJ5RFBSIiwidmFsdWUiLCJkcHIiLCJNYXRoIiwicm91bmQiLCJ1c2VMYXRlc3RSZWYiLCJyZWYiLCJ1c2VSZWYiLCJjdXJyZW50IiwidXNlRmxvYXRpbmciLCJvcHRpb25zIiwicGxhY2VtZW50Iiwic3RyYXRlZ3kiLCJtaWRkbGV3YXJlIiwiZWxlbWVudHMiLCJyZWZlcmVuY2UiLCJleHRlcm5hbFJlZmVyZW5jZSIsImZsb2F0aW5nIiwiZXh0ZXJuYWxGbG9hdGluZyIsInRyYW5zZm9ybSIsIndoaWxlRWxlbWVudHNNb3VudGVkIiwib3BlbiIsImRhdGEiLCJzZXREYXRhIiwidXNlU3RhdGUiLCJ4IiwieSIsIm1pZGRsZXdhcmVEYXRhIiwiaXNQb3NpdGlvbmVkIiwibGF0ZXN0TWlkZGxld2FyZSIsInNldExhdGVzdE1pZGRsZXdhcmUiLCJfcmVmZXJlbmNlIiwiX3NldFJlZmVyZW5jZSIsIl9mbG9hdGluZyIsIl9zZXRGbG9hdGluZyIsInNldFJlZmVyZW5jZSIsInVzZUNhbGxiYWNrIiwibm9kZSIsInJlZmVyZW5jZVJlZiIsInNldEZsb2F0aW5nIiwiZmxvYXRpbmdSZWYiLCJyZWZlcmVuY2VFbCIsImZsb2F0aW5nRWwiLCJkYXRhUmVmIiwiaGFzV2hpbGVFbGVtZW50c01vdW50ZWQiLCJ3aGlsZUVsZW1lbnRzTW91bnRlZFJlZiIsInBsYXRmb3JtUmVmIiwib3BlblJlZiIsInVwZGF0ZSIsImNvbmZpZyIsInRoZW4iLCJmdWxsRGF0YSIsIl9vYmplY3RTcHJlYWQiLCJpc01vdW50ZWRSZWYiLCJmbHVzaFN5bmMiLCJyZWZzIiwidXNlTWVtbyIsImZsb2F0aW5nU3R5bGVzIiwiaW5pdGlhbFN0eWxlcyIsInBvc2l0aW9uIiwibGVmdCIsInRvcCIsIndpbGxDaGFuZ2UiLCJhcnJvdyQxIiwiaXNSZWYiLCJuYW1lIiwiZm4iLCJzdGF0ZSIsInBhZGRpbmciLCJkZXBzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),\n/* harmony export */   getContainingBlock: () => (/* binding */ getContainingBlock),\n/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),\n/* harmony export */   getFrameElement: () => (/* binding */ getFrameElement),\n/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),\n/* harmony export */   getNodeName: () => (/* binding */ getNodeName),\n/* harmony export */   getNodeScroll: () => (/* binding */ getNodeScroll),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   getParentNode: () => (/* binding */ getParentNode),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   isContainingBlock: () => (/* binding */ isContainingBlock),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isLastTraversableNode: () => (/* binding */ isLastTraversableNode),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),\n/* harmony export */   isTableElement: () => (/* binding */ isTableElement),\n/* harmony export */   isTopLayer: () => (/* binding */ isTopLayer),\n/* harmony export */   isWebKit: () => (/* binding */ isWebKit)\n/* harmony export */ });\nfunction hasWindow() {\n  return false;\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLFNBQVNBLENBQUEsRUFBRztFQUNuQjtBQUNGO0FBQ0EsU0FBU0MsV0FBV0EsQ0FBQ0MsSUFBSSxFQUFFO0VBQ3pCLElBQUlDLE1BQU0sQ0FBQ0QsSUFBSSxDQUFDLEVBQUU7SUFDaEIsT0FBTyxDQUFDQSxJQUFJLENBQUNFLFFBQVEsSUFBSSxFQUFFLEVBQUVDLFdBQVcsQ0FBQyxDQUFDO0VBQzVDO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsT0FBTyxXQUFXO0FBQ3BCO0FBQ0EsU0FBU0MsU0FBU0EsQ0FBQ0osSUFBSSxFQUFFO0VBQ3ZCLElBQUlLLG1CQUFtQjtFQUN2QixPQUFPLENBQUNMLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQ0ssbUJBQW1CLEdBQUdMLElBQUksQ0FBQ00sYUFBYSxLQUFLLElBQUksR0FBRyxLQUFLLENBQUMsR0FBR0QsbUJBQW1CLENBQUNFLFdBQVcsS0FBS0MsTUFBTTtBQUNsSTtBQUNBLFNBQVNDLGtCQUFrQkEsQ0FBQ1QsSUFBSSxFQUFFO0VBQ2hDLElBQUlVLElBQUk7RUFDUixPQUFPLENBQUNBLElBQUksR0FBRyxDQUFDVCxNQUFNLENBQUNELElBQUksQ0FBQyxHQUFHQSxJQUFJLENBQUNNLGFBQWEsR0FBR04sSUFBSSxDQUFDVyxRQUFRLEtBQUtILE1BQU0sQ0FBQ0csUUFBUSxLQUFLLElBQUksR0FBRyxLQUFLLENBQUMsR0FBR0QsSUFBSSxDQUFDRSxlQUFlO0FBQ2hJO0FBQ0EsU0FBU1gsTUFBTUEsQ0FBQ1ksS0FBSyxFQUFFO0VBQ3JCLElBQUksQ0FBQ2YsU0FBUyxDQUFDLENBQUMsRUFBRTtJQUNoQixPQUFPLEtBQUs7RUFDZDtFQUNBLE9BQU9lLEtBQUssWUFBWUMsSUFBSSxJQUFJRCxLQUFLLFlBQVlULFNBQVMsQ0FB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RSxrQkFBa0IsQ0FBQztFQUN6QyxJQUFJQyxNQUFNLEVBQUU7SUFDVixNQUFNRSxZQUFZLEdBQUdDLGVBQWUsQ0FBQ0YsR0FBRyxDQUFDO0lBQ3pDLE9BQU9MLElBQUksQ0FBQ1EsTUFBTSxDQUFDSCxHQUFHLEVBQUVBLEdBQUcsQ0FBQ0ksY0FBYyxJQUFJLEVBQUUsRUFBRTNELGlCQUFpQixDQUFDcUQsa0JBQWtCLENBQUMsR0FBR0Esa0JBQWtCLEdBQUcsRUFBRSxFQUFFRyxZQUFZLElBQUlMLGVBQWUsR0FBR0Ysb0JBQW9CLENBQUNPLFlBQVksQ0FBQyxHQUFHLEVBQUUsQ0FBQztFQUMvTDtFQUNBLE9BQU9OLElBQUksQ0FBQ1EsTUFBTSxDQUFDTCxrQkFBa0IsRUFBRUosb0JBQW9CLENBQUNJLGtCQUFrQixFQUFFLEVBQUUsRUFBRUYsZUFBZSxDQUFDLENBQUM7QUFDdkc7QUFDQSxTQUFTTSxlQUFlQSxDQUFDRixHQUFHLEVBQUU7RUFDNUIsT0FBT0EsR0FBRyxDQUFDSyxNQUFNLElBQUlDLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDUCxHQUFHLENBQUNLLE1BQU0sQ0FBQyxHQUFHTCxHQUFHLENBQUNDLFlBQVksR0FBRyxJQUFJO0FBQ2xGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FjaGFja3MtaG9tZXBhZ2UvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcz8yNGVhIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGhhc1dpbmRvdygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobm9kZSkge1xuICBpZiAoaXNOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIChub2RlLm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIC8vIE1vY2tlZCBub2RlcyBpbiB0ZXN0aW5nIGVudmlyb25tZW50cyBtYXkgbm90IGJlIGluc3RhbmNlcyBvZiBOb2RlLiBCeVxuICAvLyByZXR1cm5pbmcgYCNkb2N1bWVudGAgYW4gaW5maW5pdGUgbG9vcCB3b24ndCBvY2N1ci5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yMzE3XG4gIHJldHVybiAnI2RvY3VtZW50Jztcbn1cbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50O1xuICByZXR1cm4gKG5vZGUgPT0gbnVsbCB8fCAoX25vZGUkb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHx8IHdpbmRvdztcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChub2RlKSB7XG4gIHZhciBfcmVmO1xuICByZXR1cm4gKF9yZWYgPSAoaXNOb2RlKG5vZGUpID8gbm9kZS5vd25lckRvY3VtZW50IDogbm9kZS5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3JlZi5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBOb2RlIHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5Ob2RlO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3QodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSB8fCB0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2hhZG93Um9vdCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuU2hhZG93Um9vdDtcbn1cbmNvbnN0IGludmFsaWRPdmVyZmxvd0Rpc3BsYXlWYWx1ZXMgPSAvKiNfX1BVUkVfXyovbmV3IFNldChbJ2lubGluZScsICdjb250ZW50cyddKTtcbmZ1bmN0aW9uIGlzT3ZlcmZsb3dFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIG92ZXJmbG93LFxuICAgIG92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1ksXG4gICAgZGlzcGxheVxuICB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbnxjbGlwLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSAmJiAhaW52YWxpZE92ZXJmbG93RGlzcGxheVZhbHVlcy5oYXMoZGlzcGxheSk7XG59XG5jb25zdCB0YWJsZUVsZW1lbnRzID0gLyojX19QVVJFX18qL25ldyBTZXQoWyd0YWJsZScsICd0ZCcsICd0aCddKTtcbmZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIHRhYmxlRWxlbWVudHMuaGFzKGdldE5vZGVOYW1lKGVsZW1lbnQpKTtcbn1cbmNvbnN0IHRvcExheWVyU2VsZWN0b3JzID0gWyc6cG9wb3Zlci1vcGVuJywgJzptb2RhbCddO1xuZnVuY3Rpb24gaXNUb3BMYXllcihlbGVtZW50KSB7XG4gIHJldHVybiB0b3BMYXllclNlbGVjdG9ycy5zb21lKHNlbGVjdG9yID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuY29uc3QgdHJhbnNmb3JtUHJvcGVydGllcyA9IFsndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZScsICdzY2FsZScsICdyb3RhdGUnLCAncGVyc3BlY3RpdmUnXTtcbmNvbnN0IHdpbGxDaGFuZ2VWYWx1ZXMgPSBbJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUnLCAnc2NhbGUnLCAncm90YXRlJywgJ3BlcnNwZWN0aXZlJywgJ2ZpbHRlciddO1xuY29uc3QgY29udGFpblZhbHVlcyA9IFsncGFpbnQnLCAnbGF5b3V0JywgJ3N0cmljdCcsICdjb250ZW50J107XG5mdW5jdGlvbiBpc0NvbnRhaW5pbmdCbG9jayhlbGVtZW50T3JDc3MpIHtcbiAgY29uc3Qgd2Via2l0ID0gaXNXZWJLaXQoKTtcbiAgY29uc3QgY3NzID0gaXNFbGVtZW50KGVsZW1lbnRPckNzcykgPyBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnRPckNzcykgOiBlbGVtZW50T3JDc3M7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy10cmFuc2Zvcm1zLTIvI2luZGl2aWR1YWwtdHJhbnNmb3Jtc1xuICByZXR1cm4gdHJhbnNmb3JtUHJvcGVydGllcy5zb21lKHZhbHVlID0+IGNzc1t2YWx1ZV0gPyBjc3NbdmFsdWVdICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgKGNzcy5jb250YWluZXJUeXBlID8gY3NzLmNvbnRhaW5lclR5cGUgIT09ICdub3JtYWwnIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5iYWNrZHJvcEZpbHRlciA/IGNzcy5iYWNrZHJvcEZpbHRlciAhPT0gJ25vbmUnIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5maWx0ZXIgPyBjc3MuZmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgd2lsbENoYW5nZVZhbHVlcy5zb21lKHZhbHVlID0+IChjc3Mud2lsbENoYW5nZSB8fCAnJykuaW5jbHVkZXModmFsdWUpKSB8fCBjb250YWluVmFsdWVzLnNvbWUodmFsdWUgPT4gKGNzcy5jb250YWluIHx8ICcnKS5pbmNsdWRlcyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgaWYgKGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSBpZiAoaXNUb3BMYXllcihjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNXZWJLaXQoKSB7XG4gIGlmICh0eXBlb2YgQ1NTID09PSAndW5kZWZpbmVkJyB8fCAhQ1NTLnN1cHBvcnRzKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBDU1Muc3VwcG9ydHMoJy13ZWJraXQtYmFja2Ryb3AtZmlsdGVyJywgJ25vbmUnKTtcbn1cbmNvbnN0IGxhc3RUcmF2ZXJzYWJsZU5vZGVOYW1lcyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddKTtcbmZ1bmN0aW9uIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShub2RlKSB7XG4gIHJldHVybiBsYXN0VHJhdmVyc2FibGVOb2RlTmFtZXMuaGFzKGdldE5vZGVOYW1lKG5vZGUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG5mdW5jdGlvbiBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpIHtcbiAgaWYgKGlzRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiB7XG4gICAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsWCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShub2RlKSB7XG4gIGlmIChnZXROb2RlTmFtZShub2RlKSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID1cbiAgLy8gU3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGUuXG4gIG5vZGUuYXNzaWduZWRTbG90IHx8XG4gIC8vIERPTSBFbGVtZW50IGRldGVjdGVkLlxuICBub2RlLnBhcmVudE5vZGUgfHxcbiAgLy8gU2hhZG93Um9vdCBkZXRlY3RlZC5cbiAgaXNTaGFkb3dSb290KG5vZGUpICYmIG5vZGUuaG9zdCB8fFxuICAvLyBGYWxsYmFjay5cbiAgZ2V0RG9jdW1lbnRFbGVtZW50KG5vZGUpO1xuICByZXR1cm4gaXNTaGFkb3dSb290KHJlc3VsdCkgPyByZXN1bHQuaG9zdCA6IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUobm9kZSk7XG4gIGlmIChpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50ID8gbm9kZS5vd25lckRvY3VtZW50LmJvZHkgOiBub2RlLmJvZHk7XG4gIH1cbiAgaWYgKGlzSFRNTEVsZW1lbnQocGFyZW50Tm9kZSkgJiYgaXNPdmVyZmxvd0VsZW1lbnQocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IocGFyZW50Tm9kZSk7XG59XG5mdW5jdGlvbiBnZXRPdmVyZmxvd0FuY2VzdG9ycyhub2RlLCBsaXN0LCB0cmF2ZXJzZUlmcmFtZXMpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQyO1xuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG4gIGlmICh0cmF2ZXJzZUlmcmFtZXMgPT09IHZvaWQgMCkge1xuICAgIHRyYXZlcnNlSWZyYW1lcyA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc2Nyb2xsYWJsZUFuY2VzdG9yID0gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3Iobm9kZSk7XG4gIGNvbnN0IGlzQm9keSA9IHNjcm9sbGFibGVBbmNlc3RvciA9PT0gKChfbm9kZSRvd25lckRvY3VtZW50MiA9IG5vZGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJG93bmVyRG9jdW1lbnQyLmJvZHkpO1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsYWJsZUFuY2VzdG9yKTtcbiAgaWYgKGlzQm9keSkge1xuICAgIGNvbnN0IGZyYW1lRWxlbWVudCA9IGdldEZyYW1lRWxlbWVudCh3aW4pO1xuICAgIHJldHVybiBsaXN0LmNvbmNhdCh3aW4sIHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNPdmVyZmxvd0VsZW1lbnQoc2Nyb2xsYWJsZUFuY2VzdG9yKSA/IHNjcm9sbGFibGVBbmNlc3RvciA6IFtdLCBmcmFtZUVsZW1lbnQgJiYgdHJhdmVyc2VJZnJhbWVzID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZnJhbWVFbGVtZW50KSA6IFtdKTtcbiAgfVxuICByZXR1cm4gbGlzdC5jb25jYXQoc2Nyb2xsYWJsZUFuY2VzdG9yLCBnZXRPdmVyZmxvd0FuY2VzdG9ycyhzY3JvbGxhYmxlQW5jZXN0b3IsIFtdLCB0cmF2ZXJzZUlmcmFtZXMpKTtcbn1cbmZ1bmN0aW9uIGdldEZyYW1lRWxlbWVudCh3aW4pIHtcbiAgcmV0dXJuIHdpbi5wYXJlbnQgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHdpbi5wYXJlbnQpID8gd2luLmZyYW1lRWxlbWVudCA6IG51bGw7XG59XG5cbmV4cG9ydCB7IGdldENvbXB1dGVkU3R5bGUsIGdldENvbnRhaW5pbmdCbG9jaywgZ2V0RG9jdW1lbnRFbGVtZW50LCBnZXRGcmFtZUVsZW1lbnQsIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yLCBnZXROb2RlTmFtZSwgZ2V0Tm9kZVNjcm9sbCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGdldFBhcmVudE5vZGUsIGdldFdpbmRvdywgaXNDb250YWluaW5nQmxvY2ssIGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBpc05vZGUsIGlzT3ZlcmZsb3dFbGVtZW50LCBpc1NoYWRvd1Jvb3QsIGlzVGFibGVFbGVtZW50LCBpc1RvcExheWVyLCBpc1dlYktpdCB9O1xuIl0sIm5hbWVzIjpbImhhc1dpbmRvdyIsImdldE5vZGVOYW1lIiwibm9kZSIsImlzTm9kZSIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJnZXRXaW5kb3ciLCJfbm9kZSRvd25lckRvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiX3JlZiIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwidmFsdWUiLCJOb2RlIiwiaXNFbGVtZW50IiwiRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJpbnZhbGlkT3ZlcmZsb3dEaXNwbGF5VmFsdWVzIiwiU2V0IiwiaXNPdmVyZmxvd0VsZW1lbnQiLCJlbGVtZW50Iiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJkaXNwbGF5IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRlc3QiLCJoYXMiLCJ0YWJsZUVsZW1lbnRzIiwiaXNUYWJsZUVsZW1lbnQiLCJ0b3BMYXllclNlbGVjdG9ycyIsImlzVG9wTGF5ZXIiLCJzb21lIiwic2VsZWN0b3IiLCJtYXRjaGVzIiwiX2UiLCJ0cmFuc2Zvcm1Qcm9wZXJ0aWVzIiwid2lsbENoYW5nZVZhbHVlcyIsImNvbnRhaW5WYWx1ZXMiLCJpc0NvbnRhaW5pbmdCbG9jayIsImVsZW1lbnRPckNzcyIsIndlYmtpdCIsImlzV2ViS2l0IiwiY3NzIiwiY29udGFpbmVyVHlwZSIsImJhY2tkcm9wRmlsdGVyIiwiZmlsdGVyIiwid2lsbENoYW5nZSIsImluY2x1ZGVzIiwiY29udGFpbiIsImdldENvbnRhaW5pbmdCbG9jayIsImN1cnJlbnROb2RlIiwiZ2V0UGFyZW50Tm9kZSIsImlzTGFzdFRyYXZlcnNhYmxlTm9kZSIsIkNTUyIsInN1cHBvcnRzIiwibGFzdFRyYXZlcnNhYmxlTm9kZU5hbWVzIiwiZ2V0Tm9kZVNjcm9sbCIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJzY3JvbGxYIiwic2Nyb2xsWSIsInJlc3VsdCIsImFzc2lnbmVkU2xvdCIsInBhcmVudE5vZGUiLCJob3N0IiwiZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IiLCJib2R5IiwiZ2V0T3ZlcmZsb3dBbmNlc3RvcnMiLCJsaXN0IiwidHJhdmVyc2VJZnJhbWVzIiwiX25vZGUkb3duZXJEb2N1bWVudDIiLCJzY3JvbGxhYmxlQW5jZXN0b3IiLCJpc0JvZHkiLCJ3aW4iLCJmcmFtZUVsZW1lbnQiLCJnZXRGcmFtZUVsZW1lbnQiLCJjb25jYXQiLCJ2aXN1YWxWaWV3cG9ydCIsInBhcmVudCIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alignments: () => (/* binding */ alignments),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   createCoords: () => (/* binding */ createCoords),\n/* harmony export */   evaluate: () => (/* binding */ evaluate),\n/* harmony export */   expandPaddingObject: () => (/* binding */ expandPaddingObject),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   getAlignment: () => (/* binding */ getAlignment),\n/* harmony export */   getAlignmentAxis: () => (/* binding */ getAlignmentAxis),\n/* harmony export */   getAlignmentSides: () => (/* binding */ getAlignmentSides),\n/* harmony export */   getAxisLength: () => (/* binding */ getAxisLength),\n/* harmony export */   getExpandedPlacements: () => (/* binding */ getExpandedPlacements),\n/* harmony export */   getOppositeAlignmentPlacement: () => (/* binding */ getOppositeAlignmentPlacement),\n/* harmony export */   getOppositeAxis: () => (/* binding */ getOppositeAxis),\n/* harmony export */   getOppositeAxisPlacements: () => (/* binding */ getOppositeAxisPlacements),\n/* harmony export */   getOppositePlacement: () => (/* binding */ getOppositePlacement),\n/* harmony export */   getPaddingObject: () => (/* binding */ getPaddingObject),\n/* harmony export */   getSide: () => (/* binding */ getSide),\n/* harmony export */   getSideAxis: () => (/* binding */ getSideAxis),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   placements: () => (/* binding */ placements),\n/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   sides: () => (/* binding */ sides)\n/* harmony export */ });\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return _objectSpread({\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }, padding);\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTUEsS0FBSyxHQUFHLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDO0FBQ2hELE1BQU1DLFVBQVUsR0FBRyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUM7QUFDbkMsTUFBTUMsVUFBVSxHQUFHLGFBQWFGLEtBQUssQ0FBQ0csTUFBTSxDQUFDLENBQUNDLEdBQUcsRUFBRUMsSUFBSSxLQUFLRCxHQUFHLENBQUNFLE1BQU0sQ0FBQ0QsSUFBSSxFQUFFQSxJQUFJLEdBQUcsR0FBRyxHQUFHSixVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUVJLElBQUksR0FBRyxHQUFHLEdBQUdKLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQUN6SSxNQUFNTSxHQUFHLEdBQUdDLElBQUksQ0FBQ0QsR0FBRztBQUNwQixNQUFNRSxHQUFHLEdBQUdELElBQUksQ0FBQ0MsR0FBRztBQUNwQixNQUFNQyxLQUFLLEdBQUdGLElBQUksQ0FBQ0UsS0FBSztBQUN4QixNQUFNQyxLQUFLLEdBQUdILElBQUksQ0FBQ0csS0FBSztBQUN4QixNQUFNQyxZQUFZLEdBQUdDLENBQUMsS0FBSztFQUN6QkMsQ0FBQyxFQUFFRCxDQUFDO0VBQ0pFLENBQUMsRUFBRUY7QUFDTCxDQUFDLENBQUM7QUFDRixNQUFNRyxlQUFlLEdBQUc7RUFDdEJDLElBQUksRUFBRSxPQUFPO0VBQ2JDLEtBQUssRUFBRSxNQUFNO0VBQ2JDLE1BQU0sRUFBRSxLQUFLO0VBQ2JDLEdBQUcsRUFBRTtBQUNQLENBQUM7QUFDRCxNQUFNQyxvQkFBb0IsR0FBRztFQUMzQkMsS0FBSyxFQUFFLEtBQUs7RUFDWkMsR0FBRyxFQUFF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b2R1bGVzL0BmbG9hdGluZy11aS91dGlscy9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLm1qcz81YWVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3VzdG9tIHBvc2l0aW9uaW5nIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3ZpcnR1YWwtZWxlbWVudHNcbiAqL1xuXG5jb25zdCBzaWRlcyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5jb25zdCBhbGlnbm1lbnRzID0gWydzdGFydCcsICdlbmQnXTtcbmNvbnN0IHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovc2lkZXMucmVkdWNlKChhY2MsIHNpZGUpID0+IGFjYy5jb25jYXQoc2lkZSwgc2lkZSArIFwiLVwiICsgYWxpZ25tZW50c1swXSwgc2lkZSArIFwiLVwiICsgYWxpZ25tZW50c1sxXSksIFtdKTtcbmNvbnN0IG1pbiA9IE1hdGgubWluO1xuY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5jb25zdCByb3VuZCA9IE1hdGgucm91bmQ7XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBjcmVhdGVDb29yZHMgPSB2ID0+ICh7XG4gIHg6IHYsXG4gIHk6IHZcbn0pO1xuY29uc3Qgb3Bwb3NpdGVTaWRlTWFwID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuY29uc3Qgb3Bwb3NpdGVBbGlnbm1lbnRNYXAgPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZnVuY3Rpb24gY2xhbXAoc3RhcnQsIHZhbHVlLCBlbmQpIHtcbiAgcmV0dXJuIG1heChzdGFydCwgbWluKHZhbHVlLCBlbmQpKTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlKHZhbHVlLCBwYXJhbSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUocGFyYW0pIDogdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRTaWRlKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBeGlzTGVuZ3RoKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbn1cbmNvbnN0IHlBeGlzU2lkZXMgPSAvKiNfX1BVUkVfXyovbmV3IFNldChbJ3RvcCcsICdib3R0b20nXSk7XG5mdW5jdGlvbiBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHlBeGlzU2lkZXMuaGFzKGdldFNpZGUocGxhY2VtZW50KSkgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gZ2V0T3Bwb3NpdGVBeGlzKGdldFNpZGVBeGlzKHBsYWNlbWVudCkpO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKSB7XG4gIGlmIChydGwgPT09IHZvaWQgMCkge1xuICAgIHJ0bCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBsZXQgbWFpbkFsaWdubWVudFNpZGUgPSBhbGlnbm1lbnRBeGlzID09PSAneCcgPyBhbGlnbm1lbnQgPT09IChydGwgPyAnZW5kJyA6ICdzdGFydCcpID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IGFsaWdubWVudCA9PT0gJ3N0YXJ0JyA/ICdib3R0b20nIDogJ3RvcCc7XG4gIGlmIChyZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSA+IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF0pIHtcbiAgICBtYWluQWxpZ25tZW50U2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKTtcbiAgfVxuICByZXR1cm4gW21haW5BbGlnbm1lbnRTaWRlLCBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSldO1xufVxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBjb25zdCBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgYWxpZ25tZW50ID0+IG9wcG9zaXRlQWxpZ25tZW50TWFwW2FsaWdubWVudF0pO1xufVxuY29uc3QgbHJQbGFjZW1lbnQgPSBbJ2xlZnQnLCAncmlnaHQnXTtcbmNvbnN0IHJsUGxhY2VtZW50ID0gWydyaWdodCcsICdsZWZ0J107XG5jb25zdCB0YlBsYWNlbWVudCA9IFsndG9wJywgJ2JvdHRvbSddO1xuY29uc3QgYnRQbGFjZW1lbnQgPSBbJ2JvdHRvbScsICd0b3AnXTtcbmZ1bmN0aW9uIGdldFNpZGVMaXN0KHNpZGUsIGlzU3RhcnQsIHJ0bCkge1xuICBzd2l0Y2ggKHNpZGUpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICBpZiAocnRsKSByZXR1cm4gaXNTdGFydCA/IHJsUGxhY2VtZW50IDogbHJQbGFjZW1lbnQ7XG4gICAgICByZXR1cm4gaXNTdGFydCA/IGxyUGxhY2VtZW50IDogcmxQbGFjZW1lbnQ7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgcmV0dXJuIGlzU3RhcnQgPyB0YlBsYWNlbWVudCA6IGJ0UGxhY2VtZW50O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW107XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMocGxhY2VtZW50LCBmbGlwQWxpZ25tZW50LCBkaXJlY3Rpb24sIHJ0bCkge1xuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgbGV0IGxpc3QgPSBnZXRTaWRlTGlzdChnZXRTaWRlKHBsYWNlbWVudCksIGRpcmVjdGlvbiA9PT0gJ3N0YXJ0JywgcnRsKTtcbiAgaWYgKGFsaWdubWVudCkge1xuICAgIGxpc3QgPSBsaXN0Lm1hcChzaWRlID0+IHNpZGUgKyBcIi1cIiArIGFsaWdubWVudCk7XG4gICAgaWYgKGZsaXBBbGlnbm1lbnQpIHtcbiAgICAgIGxpc3QgPSBsaXN0LmNvbmNhdChsaXN0Lm1hcChnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBzaWRlID0+IG9wcG9zaXRlU2lkZU1hcFtzaWRlXSk7XG59XG5mdW5jdGlvbiBleHBhbmRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgLi4ucGFkZGluZ1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiB0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBleHBhbmRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIDoge1xuICAgIHRvcDogcGFkZGluZyxcbiAgICByaWdodDogcGFkZGluZyxcbiAgICBib3R0b206IHBhZGRpbmcsXG4gICAgbGVmdDogcGFkZGluZ1xuICB9O1xufVxuZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSByZWN0O1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB0b3A6IHksXG4gICAgbGVmdDogeCxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuZXhwb3J0IHsgYWxpZ25tZW50cywgY2xhbXAsIGNyZWF0ZUNvb3JkcywgZXZhbHVhdGUsIGV4cGFuZFBhZGRpbmdPYmplY3QsIGZsb29yLCBnZXRBbGlnbm1lbnQsIGdldEFsaWdubWVudEF4aXMsIGdldEFsaWdubWVudFNpZGVzLCBnZXRBeGlzTGVuZ3RoLCBnZXRFeHBhbmRlZFBsYWNlbWVudHMsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50LCBnZXRPcHBvc2l0ZUF4aXMsIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMsIGdldE9wcG9zaXRlUGxhY2VtZW50LCBnZXRQYWRkaW5nT2JqZWN0LCBnZXRTaWRlLCBnZXRTaWRlQXhpcywgbWF4LCBtaW4sIHBsYWNlbWVudHMsIHJlY3RUb0NsaWVudFJlY3QsIHJvdW5kLCBzaWRlcyB9O1xuIl0sIm5hbWVzIjpbInNpZGVzIiwiYWxpZ25tZW50cyIsInBsYWNlbWVudHMiLCJyZWR1Y2UiLCJhY2MiLCJzaWRlIiwiY29uY2F0IiwibWluIiwiTWF0aCIsIm1heCIsInJvdW5kIiwiZmxvb3IiLCJjcmVhdGVDb29yZHMiLCJ2IiwieCIsInkiLCJvcHBvc2l0ZVNpZGVNYXAiLCJsZWZ0IiwicmlnaHQiLCJib3R0b20iLCJ0b3AiLCJvcHBvc2l0ZUFsaWdubWVudE1hcCIsInN0YXJ0IiwiZW5kIiwiY2xhbXAiLCJ2YWx1ZSIsImV2YWx1YXRlIiwicGFyYW0iLCJnZXRTaWRlIiwicGxhY2VtZW50Iiwic3BsaXQiLCJnZXRBbGlnbm1lbnQiLCJnZXRPcHBvc2l0ZUF4aXMiLCJheGlzIiwiZ2V0QXhpc0xlbmd0aCIsInlBeGlzU2lkZXMiLCJTZXQiLCJnZXRTaWRlQXhpcyIsImhhcyIsImdldEFsaWdubWVudEF4aXMiLCJnZXRBbGlnbm1lbnRTaWRlcyIsInJlY3RzIiwicnRsIiwiYWxpZ25tZW50IiwiYWxpZ25tZW50QXhpcyIsImxlbmd0aCIsIm1haW5BbGlnbm1lbnRTaWRlIiwicmVmZXJlbmNlIiwiZmxvYXRpbmciLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsImdldEV4cGFuZGVkUGxhY2VtZW50cyIsIm9wcG9zaXRlUGxhY2VtZW50IiwiZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQiLCJyZXBsYWNlIiwibHJQbGFjZW1lbnQiLCJybFBsYWNlbWVudCIsInRiUGxhY2VtZW50IiwiYnRQbGFjZW1lbnQiLCJnZXRTaWRlTGlzdCIsImlzU3RhcnQiLCJnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzIiwiZmxpcEFsaWdubWVudCIsImRpcmVjdGlvbiIsImxpc3QiLCJtYXAiLCJleHBhbmRQYWRkaW5nT2JqZWN0IiwicGFkZGluZyIsIl9vYmplY3RTcHJlYWQiLCJnZXRQYWRkaW5nT2JqZWN0IiwicmVjdFRvQ2xpZW50UmVjdCIsInJlY3QiLCJ3aWR0aCIsImhlaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\n");

/***/ })

};
;